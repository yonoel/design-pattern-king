# 86 | 开源实战四（下）：总结Spring框架用到的11种设计模式

王争 2020-05-20

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：10.31M 时长：12:51

上一节课，我们讲解了 Spring 中支持扩展功能的两种设计模式：观察者模式和模板模式。这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。

实际上，Spring 框架中用到的设计模式非常多，不下十几种。我们今天就总结罗列一下它们。限于篇幅，我不可能对每种设计模式都进行非常详细的讲解。有些前面已经讲过的或者比较简单的，我就点到为止。如果有什么不是很懂的地方，你可以通过阅读源码，查阅之前的理论讲解，自己去搞定它。如果一直跟着我的课程学习，相信你现在已经具备这样的学习能力。

话不多说，让我们正式开始今天的学习吧！

## 适配器模式在 Spring 中的应用

在 Spring MVC 中，定义一个 Controller 最常用的方式是，通过 @Controller 注解来标记某个类是 Controller 类，通过 @RequesMapping 注解来标记函数对应的 URL。不过，定义一个 Controller 远不止这一种方法。我们还可以通过让类实现 Controller 接口或者 Servlet 接口，来定义一个 Controller。针对这三种定义方式，我写了三段示例代码，如下所示：

// 方法一：通过@Controller、@RequestMapping来定义

@Controller

public class DemoController {

​    @RequestMapping("/employname")

​    public ModelAndView getEmployeeName() {

​        ModelAndView model = new ModelAndView("Greeting");        

​        model.addObject("message", "Dinesh");       

​        return model; 

​    }  

}

// 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系

public class DemoController implements Controller {

​    @Override

​    public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception {

​        ModelAndView model = new ModelAndView("Greeting");

​        model.addObject("message", "Dinesh Madhwal");

​        return model;

​    }

}

// 方法三：实现Servlet接口 + xml配置文件:配置DemoController类与URL的对应关系

public class DemoServlet extends HttpServlet {

  @Override

  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

​    this.doPost(req, resp);

  }

  

  @Override

  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

​    resp.getWriter().write("Hello World.");

  }

}

在应用启动的时候，Spring 容器会加载这些 Controller 类，并且解析出 URL 对应的处理函数，封装成 Handler 对象，存储到 HandlerMapping 对象中。当有请求到来的时候，DispatcherServlet 从 HanderMapping 中，查找请求 URL 对应的 Handler，然后调用执行 Handler 对应的函数代码，最后将执行结果返回给客户端。

但是，不同方式定义的 Controller，其函数的定义（函数名、入参、返回值等）是不统一的。如上示例代码所示，方法一中的函数的定义很随意、不固定，方法二中的函数定义是 handleRequest()、方法三中的函数定义是 service()（看似是定义了 doGet()、doPost()，实际上，这里用到了模板模式，Servlet 中的 service() 调用了 doGet() 或 doPost() 方法，DispatcherServlet 调用的是 service() 方法）。DispatcherServlet 需要根据不同类型的 Controller，调用不同的函数。下面是具体的伪代码：

Handler handler = handlerMapping.get(URL);

if (handler instanceof Controller) {

  ((Controller)handler).handleRequest(...);

} else if (handler instanceof Servlet) {

  ((Servlet)handler).service(...);

} else if (hanlder 对应通过注解来定义的Controller) {

  反射调用方法...

}

从代码中我们可以看出，这种实现方式会有很多 if-else 分支判断，而且，如果要增加一个新的 Controller 的定义方法，我们就要在 DispatcherServlet 类代码中，对应地增加一段如上伪代码所示的 if 逻辑。这显然不符合开闭原则。

实际上，我们可以利用是适配器模式对代码进行改造，让其满足开闭原则，能更好地支持扩展。在[第 51 节课](undefined)中，我们讲到，适配器其中一个作用是“统一多个类的接口设计”。利用适配器模式，我们将不同方式定义的 Controller 类中的函数，适配为统一的函数定义。这样，我们就能在 DispatcherServlet 类代码中，移除掉 if-else 分支判断逻辑，调用统一的函数。

刚刚讲了大致的设计思路，我们再具体看下 Spring 的代码实现。

Spring 定义了统一的接口 HandlerAdapter，并且对每种 Controller 定义了对应的适配器类。这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter 等。源码我贴到了下面，你可以结合着看下。

public interface HandlerAdapter {

  boolean supports(Object var1);

  ModelAndView handle(HttpServletRequest var1, HttpServletResponse var2, Object var3) throws Exception;

  long getLastModified(HttpServletRequest var1, Object var2);

}

// 对应实现Controller接口的Controller

public class SimpleControllerHandlerAdapter implements HandlerAdapter {

  public SimpleControllerHandlerAdapter() {

  }

  public boolean supports(Object handler) {

​    return handler instanceof Controller;

  }

  public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

​    return ((Controller)handler).handleRequest(request, response);

  }

  public long getLastModified(HttpServletRequest request, Object handler) {

​    return handler instanceof LastModified ? ((LastModified)handler).getLastModified(request) : -1L;

  }

}

// 对应实现Servlet接口的Controller

public class SimpleServletHandlerAdapter implements HandlerAdapter {

  public SimpleServletHandlerAdapter() {

  }

  public boolean supports(Object handler) {

​    return handler instanceof Servlet;

  }

  public ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

​    ((Servlet)handler).service(request, response);

​    return null;

  }

  public long getLastModified(HttpServletRequest request, Object handler) {

​    return -1L;

  }

}

//AnnotationMethodHandlerAdapter对应通过注解实现的Controller，

//代码太多了，我就不贴在这里了

在 DispatcherServlet 类中，我们就不需要区分对待不同的 Controller 对象了，统一调用 HandlerAdapter 的 handle() 函数就可以了。按照这个思路实现的伪代码如下所示。你看，这样就没有烦人的 if-else 逻辑了吧？

// 之前的实现方式

Handler handler = handlerMapping.get(URL);

if (handler instanceof Controller) {

  ((Controller)handler).handleRequest(...);

} else if (handler instanceof Servlet) {

  ((Servlet)handler).service(...);

} else if (hanlder 对应通过注解来定义的Controller) {

  反射调用方法...

}

// 现在实现方式

HandlerAdapter handlerAdapter = handlerMapping.get(URL);

handlerAdapter.handle(...);

## 策略模式在 Spring 中的应用

我们前面讲到，Spring AOP 是通过动态代理来实现的。熟悉 Java 的同学应该知道，具体到代码实现，Spring 支持两种动态代理实现方式，一种是 JDK 提供的动态代理实现方式，另一种是 Cglib 提供的动态代理实现方式。

前者需要被代理的类有抽象的接口定义，后者不需要（这两种动态代理实现方式的更多区别请自行百度研究吧）。针对不同的被代理类，Spring 会在运行时动态地选择不同的动态代理实现方式。这个应用场景实际上就是策略模式的典型应用场景。

我们前面讲过，策略模式包含三部分，策略的定义、创建和使用。接下来，我们具体看下，这三个部分是如何体现在 Spring 源码中的。

在策略模式中，策略的定义这一部分很简单。我们只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到 Spring 源码，AopProxy 是策略接口，JdkDynamicAopProxy、CglibAopProxy 是两个实现了 AopProxy 接口的策略类。其中，AopProxy 接口的定义如下所示：

public interface AopProxy {

  Object getProxy();

  Object getProxy(ClassLoader var1);

}

在策略模式中，策略的创建一般通过工厂方法来实现。对应到 Spring 源码，AopProxyFactory 是一个工厂类接口，DefaultAopProxyFactory 是一个默认的工厂类，用来创建 AopProxy 对象。两者的源码如下所示：

public interface AopProxyFactory {

  AopProxy createAopProxy(AdvisedSupport var1) throws AopConfigException;

}

public class DefaultAopProxyFactory implements AopProxyFactory, Serializable {

  public DefaultAopProxyFactory() {

  }

  public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {

​    if (!config.isOptimize() && !config.isProxyTargetClass() && !this.hasNoUserSuppliedProxyInterfaces(config)) {

​      return new JdkDynamicAopProxy(config);

​    } else {

​      Class<?> targetClass = config.getTargetClass();

​      if (targetClass == null) {

​        throw new AopConfigException("TargetSource cannot determine target class: Either an interface or a target is required for proxy creation.");

​      } else {

​        return (AopProxy)(!targetClass.isInterface() && !Proxy.isProxyClass(targetClass) ? new ObjenesisCglibAopProxy(config) : new JdkDynamicAopProxy(config));

​      }

​    }

  }

  //用来判断用哪个动态代理实现方式

  private boolean hasNoUserSuppliedProxyInterfaces(AdvisedSupport config) {

​    Class<?>[] ifcs = config.getProxiedInterfaces();

​    return ifcs.length == 0 || ifcs.length == 1 && SpringProxy.class.isAssignableFrom(ifcs[0]);

  }

}

策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。对应到 Spring 源码中，我们可以参看刚刚给出的 DefaultAopProxyFactory 类中的 createAopProxy() 函数的代码实现。其中，第 10 行代码是动态选择哪种策略的判断条件。

## 组合模式在 Spring 中的应用

上节课讲到 Spring“再封装、再抽象”设计思想的时候，我们提到了 Spring Cache。Spring Cache 提供了一套抽象的 Cache 接口。使用它我们能够统一不同缓存实现（Redis、Google Guava…）的不同的访问方式。Spring 中针对不同缓存实现的不同缓存访问类，都依赖这个接口，比如：EhCacheCache、GuavaCache、NoOpCache、RedisCache、JCacheCache、ConcurrentMapCache、CaffeineCache。Cache 接口的源码如下所示：

public interface Cache {

  String getName();

  Object getNativeCache();

  Cache.ValueWrapper get(Object var1);

  <T> T get(Object var1, Class<T> var2);

  <T> T get(Object var1, Callable<T> var2);

  void put(Object var1, Object var2);

  Cache.ValueWrapper putIfAbsent(Object var1, Object var2);

  void evict(Object var1);

  void clear();

  public static class ValueRetrievalException extends RuntimeException {

​    private final Object key;

​    public ValueRetrievalException(Object key, Callable<?> loader, Throwable ex) {

​      super(String.format("Value for key '%s' could not be loaded using '%s'", key, loader), ex);

​      this.key = key;

​    }

​    public Object getKey() {

​      return this.key;

​    }

  }

  public interface ValueWrapper {

​    Object get();

  }

}

在实际的开发中，一个项目有可能会用到多种不同的缓存，比如既用到 Google Guava 缓存，也用到 Redis 缓存。除此之外，同一个缓存实例，也可以根据业务的不同，分割成多个小的逻辑缓存单元（或者叫作命名空间）。

为了管理多个缓存，Spring 还提供了缓存管理功能。不过，它包含的功能很简单，主要有这样两部分：一个是根据缓存名字（创建 Cache 对象的时候要设置 name 属性）获取 Cache 对象；另一个是获取管理器管理的所有缓存的名字列表。对应的 Spring 源码如下所示：

public interface CacheManager {

  Cache getCache(String var1);

  Collection<String> getCacheNames();

}

刚刚给出的是 CacheManager 接口的定义，那如何来实现这两个接口呢？实际上，这就要用到了我们之前讲过的组合模式。

我们前面讲过，组合模式主要应用在能表示成树形结构的一组数据上。树中的结点分为叶子节点和中间节点两类。对应到 Spring 源码，EhCacheManager、SimpleCacheManager、NoOpCacheManager、RedisCacheManager 等表示叶子节点，CompositeCacheManager 表示中间节点。

叶子节点包含的是它所管理的 Cache 对象，中间节点包含的是其他 CacheManager 管理器，既可以是 CompositeCacheManager，也可以是具体的管理器，比如 EhCacheManager、RedisManager 等。

我把 CompositeCacheManger 的代码贴到了下面，你可以结合着讲解一块看下。其中，getCache()、getCacheNames() 两个函数的实现都用到了递归。这正是树形结构最能发挥优势的地方。

public class CompositeCacheManager implements CacheManager, InitializingBean {

  private final List<CacheManager> cacheManagers = new ArrayList();

  private boolean fallbackToNoOpCache = false;

  public CompositeCacheManager() {

  }

  public CompositeCacheManager(CacheManager... cacheManagers) {

​    this.setCacheManagers(Arrays.asList(cacheManagers));

  }

  public void setCacheManagers(Collection<CacheManager> cacheManagers) {

​    this.cacheManagers.addAll(cacheManagers);

  }

  public void setFallbackToNoOpCache(boolean fallbackToNoOpCache) {

​    this.fallbackToNoOpCache = fallbackToNoOpCache;

  }

  public void afterPropertiesSet() {

​    if (this.fallbackToNoOpCache) {

​      this.cacheManagers.add(new NoOpCacheManager());

​    }

  }

  public Cache getCache(String name) {

​    Iterator var2 = this.cacheManagers.iterator();

​    Cache cache;

​    do {

​      if (!var2.hasNext()) {

​        return null;

​      }

​      CacheManager cacheManager = (CacheManager)var2.next();

​      cache = cacheManager.getCache(name);

​    } while(cache == null);

​    return cache;

  }

  public Collection<String> getCacheNames() {

​    Set<String> names = new LinkedHashSet();

​    Iterator var2 = this.cacheManagers.iterator();

​    while(var2.hasNext()) {

​      CacheManager manager = (CacheManager)var2.next();

​      names.addAll(manager.getCacheNames());

​    }

​    return Collections.unmodifiableSet(names);

  }

}

## 装饰器模式在 Spring 中的应用

我们知道，缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。为了解决这个问题，我们需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败。

实现这样一个功能，Spring 使用到了装饰器模式。TransactionAwareCacheDecorator 增加了对事务的支持，在事务提交、回滚的时候分别对 Cache 的数据进行处理。

TransactionAwareCacheDecorator 实现 Cache 接口，并且将所有的操作都委托给 targetCache 来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现，我就不多作解释了。

public class TransactionAwareCacheDecorator implements Cache {

  private final Cache targetCache;

  public TransactionAwareCacheDecorator(Cache targetCache) {

​    Assert.notNull(targetCache, "Target Cache must not be null");

​    this.targetCache = targetCache;

  }

  public Cache getTargetCache() {

​    return this.targetCache;

  }

  public String getName() {

​    return this.targetCache.getName();

  }

  public Object getNativeCache() {

​    return this.targetCache.getNativeCache();

  }

  public ValueWrapper get(Object key) {

​    return this.targetCache.get(key);

  }

  public <T> T get(Object key, Class<T> type) {

​    return this.targetCache.get(key, type);

  }

  public <T> T get(Object key, Callable<T> valueLoader) {

​    return this.targetCache.get(key, valueLoader);

  }

  public void put(final Object key, final Object value) {

​    if (TransactionSynchronizationManager.isSynchronizationActive()) {

​      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {

​        public void afterCommit() {

​          TransactionAwareCacheDecorator.this.targetCache.put(key, value);

​        }

​      });

​    } else {

​      this.targetCache.put(key, value);

​    }

  }

  

  public ValueWrapper putIfAbsent(Object key, Object value) {

​    return this.targetCache.putIfAbsent(key, value);

  }

  public void evict(final Object key) {

​    if (TransactionSynchronizationManager.isSynchronizationActive()) {

​      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {

​        public void afterCommit() {

​          TransactionAwareCacheDecorator.this.targetCache.evict(key);

​        }

​      });

​    } else {

​      this.targetCache.evict(key);

​    }

  }

  public void clear() {

​    if (TransactionSynchronizationManager.isSynchronizationActive()) {

​      TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {

​        public void afterCommit() {

​          TransactionAwareCacheDecorator.this.targetCache.clear();

​        }

​      });

​    } else {

​      this.targetCache.clear();

​    }

  }

}

## 工厂模式在 Spring 中的应用

在 Spring 中，工厂模式最经典的应用莫过于实现 IOC 容器，对应的 Spring 源码主要是 BeanFactory 类和 ApplicationContext 相关类（AbstractApplicationContext、ClassPathXmlApplicationContext、FileSystemXmlApplicationContext…）。除此之外，在理论部分，我还带你手把手实现了一个简单的 IOC 容器。你可以回过头去再看下。

在 Spring 中，创建 Bean 的方式有很多种，比如前面提到的纯构造函数、无参构造函数加 setter 方法。我写了一个例子来说明这两种创建方式，代码如下所示：

public class Student {

  private long id;

  private String name;

  

  public Student(long id, String name) {

​    this.id = id;

​    this.name = name;

  }

  

  public void setId(long id) {

​    this.id = id;

  }

  

  public void setName(String name) {

​    this.name = name;

  }

}

// 使用构造函数来创建Bean

<bean id="student" class="com.xzg.cd.Student">

​    <constructor-arg name="id" value="1"/>

​    <constructor-arg name="name" value="wangzheng"/>

</bean>

// 使用无参构造函数+setter方法来创建Bean

<bean id="student" class="com.xzg.cd.Student">

​    <property name="id" value="1"></property>

​    <property name="name" value="wangzheng"></property>

</bean>

实际上，除了这两种创建 Bean 的方式之外，我们还可以通过工厂方法来创建 Bean。还是刚刚这个例子，用这种方式来创建 Bean 的话就是下面这个样子：

public class StudentFactory {

  private static Map<Long, Student> students = new HashMap<>();

  

  static{

​    map.put(1, new Student(1,"wang"));

​    map.put(2, new Student(2,"zheng"));

​    map.put(3, new Student(3,"xzg"));

  }

 

  public static Student getStudent(long id){

​    return students.get(id);

  }

}

// 通过工厂方法getStudent(2)来创建BeanId="zheng""的Bean

<bean id="zheng" class="com.xzg.cd.StudentFactory" factory-method="getStudent">

​    <constructor-arg value="2"></constructor-arg>           

</bean>

## 其他模式在 Spring 中的应用

前面的几个模式在 Spring 中的应用讲解的都比较详细，接下来的几个模式，大部分都是我们之前讲过的，这里只是简单总结一下，点到为止，如果你对哪块有遗忘，可以回过头去看下理论部分的讲解。

SpEL，全称叫 Spring Expression Language，是 Spring 中常用来编写配置的表达式语言。它定义了一系列的语法规则。我们只要按照这些语法规则来编写表达式，Spring 就能解析出表达式的含义。实际上，这就是我们前面讲到的解释器模式的典型应用场景。

因为解释器模式没有一个非常固定的代码实现结构，而且 Spring 中 SpEL 相关的代码也比较多，所以这里就不带你一块阅读源码了。如果感兴趣或者项目中正好要实现类似的功能的时候，你可以再去阅读、借鉴它的代码实现。代码主要集中在 spring-expresssion 这个模块下面。

前面讲到单例模式的时候，我提到过，单例模式有很多弊端，比如单元测试不友好等。应对策略就是通过 IOC 容器来管理对象，通过 IOC 容器来实现对象的唯一性的控制。实际上，这样实现的单例并非真正的单例，它的唯一性的作用范围仅仅在同一个 IOC 容器内。

除此之外，Spring 还用到了观察者模式、模板模式、职责链模式、代理模式。其中，观察者模式、模板模式在上一节课已经详细讲过了。

实际上，在 Spring 中，只要后缀带有 Template 的类，基本上都是模板类，而且大部分都是用 Callback 回调来实现的，比如 JdbcTemplate、RedisTemplate 等。剩下的两个模式在 Spring 中的应用应该人尽皆知了。职责链模式在 Spring 中的应用是拦截器（Interceptor），代理模式经典应用是 AOP。

## 重点回顾

好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。

我们今天提到的设计模式有 11 种，它们分别是适配器模式、策略模式、组合模式、装饰器模式、工厂模式、单例模式、解释器模式、观察者模式、模板模式、职责链模式、代理模式，基本上占了 23 种设计模式的一半。这还只是我所知道的，实际上，Spring 用到的设计模式可能还要更多。你看，设计模式并非“花拳绣腿”吧，它在实际的项目开发中，确实有很多应用，确实可以发挥很大的作用。

还是那句话，对于今天的内容，你不需要去记忆哪个类用到了哪个设计模式。你只需要跟着我的讲解，把每个设计模式在 Spring 中的应用场景，搞懂就可以了。看到类似的代码，能够立马识别出它用到了哪种设计模式；看到类似的应用场景，能够立马反映出要用哪种模式去解决，这样就说明你已经掌握得足够好了。

## 课堂讨论

我们前面讲到，除了纯构造函数、构造函数加 setter 方法和工厂方法之外，还有另外一个经常用来创建对象的模式，Builder 模式。如果我们让 Spring 支持通过 Builder 模式来创建 Bean，应该如何来编写代码和配置呢？你可以设计一下吗？

# 87 | 开源实战五（上）：MyBatis如何权衡易用性、性能和灵活性？

王争 2020-05-22

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：8.52M 时长：09:18

上几节课我们讲到了 Spring 框架，剖析了背后蕴含的一些通用设计思想，以及用到的十几种设计模式。从今天开始，我们再剖析另外一个 Java 项目开发中经常用到的框架：MyBatis。因为内容比较多，同样，我们也分三节课来讲解。

第一节课，我们分析 MyBatis 如何权衡代码的易用性、性能和灵活性。

第二节课，我们学习如何利用职责链与代理模式实现 MyBatis Plugin。

第三节课，我们总结罗列一下 MyBatis 框架中用到的十几种设计模式。

话不多说，让我们正式开始今天的学习吧！

## Mybatis 和 ORM 框架介绍

熟悉 Java 的同学应该知道，MyBatis 是一个 ORM（Object Relational Mapping，对象 - 关系映射）框架。ORM 框架主要是根据类和数据库表之间的映射关系，帮助程序员自动实现对象与数据库中数据之间的互相转化。说得更具体点就是，ORM 负责将程序中的对象存储到数据库中、将数据库中的数据转化为程序中的对象。实际上，Java 中的 ORM 框架有很多，除了刚刚提到的 MyBatis 之外，还有 Hibernate、TopLink 等。

在剖析 Spring 框架的时候，我们讲到，如果用一句话来总结框架作用的话，那就是简化开发。MyBatis 框架也不例外。它简化的是数据库方面的开发。那 MyBatis 是如何简化数据库开发的呢？我们结合[第 59 讲](undefined)中的 JdbcTemplate 的例子来说明一下。

在第 59 讲中，我们讲到，Java 提供了 JDBC 类库来封装不同类型的数据库操作。不过，直接使用 JDBC 来进行数据库编程，还是有点麻烦的。于是，Spring 提供了 JdbcTemplate，对 JDBC 进一步封装，来进一步简化数据库编程。

使用 JdbcTemplate 进行数据库编程，我们只需要编写跟业务相关的代码（比如，SQL 语句、数据库中数据与对象之间的互相转化的代码），其他流程性质的代码（比如，加载驱动、创建数据库连接、创建 statement、关闭连接、关闭 statement 等）都封装在了 JdbcTemplate 类中，不需要我们重复编写。

当时，为了展示使用 JdbcTemplate 是如何简化数据库编程的，我们还举了一个查询数据库中用户信息的例子。还是同样这个例子，我再来看下，使用 MyBatis 该如何实现，是不是比使用 JdbcTemplate 更加简单。

因为 MyBatis 依赖 JDBC 驱动，所以，在项目中使用 MyBatis，除了需要引入 MyBatis 框架本身（mybatis.jar）之外，还需要引入 JDBC 驱动（比如，访问 MySQL 的 JDBC 驱动实现类库 mysql-connector-java.jar）。将两个 jar 包引入项目之后，我们就可以开始编程了。使用 MyBatis 来访问数据库中用户信息的代码如下所示：

// 1. 定义UserDO

public class UserDo {

  private long id;

  private String name;

  private String telephone;

  // 省略setter/getter方法

}

// 2. 定义访问接口

public interface UserMapper {

  public UserDo selectById(long id);

}

// 3. 定义映射关系：UserMapper.xml

<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE mapper PUBLIC "-//mybatis.org/DTD Mapper 3.0//EN"

​        "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >

<mapper namespace="cn.xzg.cd.a87.repo.mapper.UserMapper">

​    <select id="selectById" resultType="cn.xzg.cd.a87.repo.UserDo">

​        select * from user where id=#{id}

​    </select>

</mapper>

// 4. 全局配置文件: mybatis.xml

<?xml version="1.0" encoding="UTF-8" ?>

<!DOCTYPE configuration

​        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"

​        "http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>

​    <environments default="dev">

​        <environment id="dev">

​            <transactionManager type="JDBC"></transactionManager>

​            <dataSource type="POOLED">

​                <property name="driver" value="com.mysql.jdbc.Driver" />

​                <property name="url" value="jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=UTF-8" />

​                <property name="username" value="root" />

​                <property name="password" value="..." />

​            </dataSource>

​        </environment>

​    </environments>

​    <mappers>

​        <mapper resource="mapper/UserMapper.xml"/>

​    </mappers>

</configuration>

需要注意的是，在 UserMapper.xml 配置文件中，我们只定义了接口和 SQL 语句之间的映射关系，并没有显式地定义类（UserDo）字段与数据库表（user）字段之间的映射关系。实际上，这就体现了“约定优于配置”的设计原则。类字段与数据库表字段之间使用了默认映射关系：类字段跟数据库表中拼写相同的字段一一映射。当然，如果没办法做到一一映射，我们也可以自定义它们之间的映射关系。

有了上面的代码和配置，我们就可以像下面这样来访问数据库中的用户信息了。

public class MyBatisDemo {

  public static void main(String[] args) throws IOException {

​    Reader reader = Resources.getResourceAsReader("mybatis.xml");

​    SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader);

​    SqlSession session = sessionFactory.openSession();

​    UserMapper userMapper = session.getMapper(UserMapper.class);

​    UserDo userDo = userMapper.selectById(8);

​    //...

  }

}

从代码中，我们可以看出，相对于使用 JdbcTemplate 的实现方式，使用 MyBatis 的实现方式更加灵活。在使用 JdbcTemplate 的实现方式中，对象与数据库中数据之间的转化代码、SQL 语句，是硬编码在业务代码中的。而在使用 MyBatis 的实现方式中，类字段与数据库字段之间的映射关系、接口与 SQL 之间的映射关系，是写在 XML 配置文件中的，是跟代码相分离的，这样会更加灵活、清晰，维护起来更加方便。

## 如何平衡易用性、性能和灵活性？

刚刚我们对 MyBatis 框架做了简单介绍，接下来，我们再对比一下另外两个框架：JdbcTemplate 和 Hibernate。通过对比我们来看，MyBatis 是如何权衡代码的易用性、性能和灵活性的。

我们先来看 JdbcTemplate。相对于 MyBatis 来说，JdbcTemplate 更加轻量级。因为它对 JDBC 只做了很简单的封装，所以性能损耗比较少。相对于其他两个框架来说，它的性能最好。但是，它的缺点也比较明显，那就是 SQL 与代码耦合在一起，而且不具备 ORM 的功能，需要自己编写代码，解析对象跟数据库中的数据之间的映射关系。所以，在易用性上它不及其他两个框架。

我们再来看 Hibernate。相对于 MyBatis 来说，Hibernate 更加重量级。Hibernate 提供了更加高级的映射功能，能够根据业务需求自动生成 SQL 语句。我们不需要像使用 MyBatis 那样自己编写 SQL。因此，有的时候，我们也把 MyBatis 称作半自动化的 ORM 框架，把 Hibernate 称作全自动化的 ORM 框架。不过，虽然自动生成 SQL 简化了开发，但是毕竟是自动生成的，没有针对性的优化。在性能方面，这样得到的 SQL 可能没有程序员编写得好。同时，这样也丧失了程序员自己编写 SQL 的灵活性。

实际上，不管用哪种实现方式，从数据库中取出数据并且转化成对象，这个过程涉及的代码逻辑基本是一致的。不同实现方式的区别，只不过是哪部分代码逻辑放到了哪里。有的框架提供的功能比较强大，大部分代码逻辑都由框架来完成，程序员只需要实现很小的一部分代码就可以了。这样框架的易用性就更好些。但是，框架集成的功能越多，为了处理逻辑的通用性，就会引入更多额外的处理代码。比起针对具体问题具体编程，这样性能损耗就相对大一些。

所以，粗略地讲，有的时候，框架的易用性和性能成对立关系。追求易用性，那性能就差一些。相反，追求性能，易用性就差一些。除此之外，使用起来越简单，那灵活性就越差。这就好比我们用的照相机。傻瓜相机按下快门就能拍照，但没有复杂的单反灵活。

实际上，JdbcTemplate、MyBatis、Hibernate 这几个框架也体现了刚刚说的这个规律。

JdbcTemplate 提供的功能最简单，易用性最差，性能损耗最少，用它编程性能最好。Hibernate 提供的功能最完善，易用性最好，但相对来说性能损耗就最高了。MyBatis 介于两者中间，在易用性、性能、灵活性三个方面做到了权衡。它支撑程序员自己编写 SQL，能够延续程序员对 SQL 知识的积累。相对于完全黑盒子的 Hibernate，很多程序员反倒是更加喜欢 MyBatis 这种半透明的框架。这也提醒我们，过度封装，提供过于简化的开发方式，也会丧失开发的灵活性。

## 重点回顾

好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。

如果你熟悉 Java 和 MyBatis，那你应该掌握今天讲到 JDBC、JdbcTemplate、MyBatis、Hibernate 之间的区别。JDBC 是 Java 访问数据库的开发规范，提供了一套抽象的统一的开发接口，隐藏不同数据库的访问细节。

JdbcTemplate、MyBatis、Hibernate 都是对 JDBC 的二次封装，为的是进一步简化数据库开发。其中，JdbcTemplate 不能算得上是 ORM 框架，因为还需要程序员自己编程来实现对象和数据库数据之间的互相转化。相对于 Hibernate 这种连 SQL 都不用程序员自己写的全自动 ORM 框架，MyBatis 算是一种半自动化的 ORM 框架。

如果你不熟悉 Java 和 MyBatis，作为背景介绍，那你简单了解一下 MyBatis 和 ORM 就可以了。不过，在你熟悉的语言中，应该也有相应的 ORM 框架，你也可以对比着去分析一下。

今天的内容除了起到对 MyBatis 做背景介绍之外，我们还学习了代码的易用性、性能、灵活性之间的关系。一般来讲，提供的高级功能越多，那性能损耗就会越大些；用起来越简单，提供越简化的开发方式，那灵活性也就相对越低。

## 课堂讨论

在你的项目开发中，有没有用过哪些框架，能够切实地提高开发效率，减少不必要的体力劳动？

# 88 | 开源实战五（中）：如何利用职责链与代理模式实现MyBatis Plugin？

王争 2020-05-25

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：10.04M 时长：10:57

上节课，我们对 MyBatis 框架做了简单的背景介绍，并且通过对比各种 ORM 框架，学习了代码的易用性、性能、灵活性之间的关系。一般来讲，框架提供的高级功能越多，那性能损耗就会越大；框架用起来越简单，提供越简化的使用方式，那灵活性也就越低。

接下来的两节课，我们再学习一下 MyBatis 用到一些经典设计模式。其中，今天，我们主要讲解 MyBatis Plugin。尽管名字叫 Plugin（插件），但它实际上跟之前讲到的 Servlet Filter（过滤器）、Spring Interceptor（拦截器）类似，设计的初衷都是为了框架的扩展性，用到的主要设计模式都是职责链模式。

不过，相对于 Servlet Filter 和 Spring Interceptor，MyBatis Plugin 中职责链模式的代码实现稍微有点复杂。它是借助动态代理模式来实现的职责链。今天我就带你看下，如何利用这两个模式实现 MyBatis Plugin。

话不多说，让我们正式开始今天的学习吧！

## MyBatis Plugin 功能介绍

实际上，MyBatis Plugin 跟 Servlet Filter、Spring Interceptor 的功能是类似的，都是在不需要修改原有流程代码的情况下，拦截某些方法调用，在拦截的方法调用的前后，执行一些额外的代码逻辑。它们的唯一区别在于拦截的位置是不同的。Servlet Filter 主要拦截 Servlet 请求，Spring Interceptor 主要拦截 Spring 管理的 Bean 方法（比如 Controller 类的方法等），而 MyBatis Plugin 主要拦截的是 MyBatis 在执行 SQL 的过程中涉及的一些方法。

MyBatis Plugin 使用起来比较简单，我们通过一个例子来快速看下。

假设我们需要统计应用中每个 SQL 的执行耗时，如果使用 MyBatis Plugin 来实现的话，我们只需要定义一个 SqlCostTimeInterceptor 类，让它实现 MyBatis 的 Interceptor 接口，并且，在 MyBatis 的全局配置文件中，简单声明一下这个插件就可以了。具体的代码和配置如下所示：

@Intercepts({

​        @Signature(type = StatementHandler.class, method = "query", args = {Statement.class, ResultHandler.class}),

​        @Signature(type = StatementHandler.class, method = "update", args = {Statement.class}),

​        @Signature(type = StatementHandler.class, method = "batch", args = {Statement.class})})

public class SqlCostTimeInterceptor implements Interceptor {

  private static Logger logger = LoggerFactory.getLogger(SqlCostTimeInterceptor.class);

  @Override

  public Object intercept(Invocation invocation) throws Throwable {

​    Object target = invocation.getTarget();

​    long startTime = System.currentTimeMillis();

​    StatementHandler statementHandler = (StatementHandler) target;

​    try {

​      return invocation.proceed();

​    } finally {

​      long costTime = System.currentTimeMillis() - startTime;

​      BoundSql boundSql = statementHandler.getBoundSql();

​      String sql = boundSql.getSql();

​      logger.info("执行 SQL：[ {} ]执行耗时[ {} ms]", sql, costTime);

​    }

  }

  @Override

  public Object plugin(Object target) {

​    return Plugin.wrap(target, this);

  }

  @Override

  public void setProperties(Properties properties) {

​    System.out.println("插件配置的信息："+properties);

  }

}

<!-- MyBatis全局配置文件：mybatis-config.xml -->

<plugins>

  <plugin interceptor="com.xzg.cd.a88.SqlCostTimeInterceptor">

​    <property name="someProperty" value="100"/>

  </plugin>

</plugins>

因为待会我会详细地介绍 MyBatis Plugin 的底层实现原理，所以，这里暂时不对上面的代码做详细地解释。现在，我们只重点看下 @Intercepts 注解这一部分。

我们知道，不管是拦截器、过滤器还是插件，都需要明确地标明拦截的目标方法。@Intercepts 注解实际上就是起了这个作用。其中，@Intercepts 注解又可以嵌套 @Signature 注解。一个 @Signature 注解标明一个要拦截的目标方法。如果要拦截多个方法，我们可以像例子中那样，编写多条 @Signature 注解。

@Signature 注解包含三个元素：type、method、args。其中，type 指明要拦截的类、method 指明方法名、args 指明方法的参数列表。通过指定这三个元素，我们就能完全确定一个要拦截的方法。

默认情况下，MyBatis Plugin 允许拦截的方法有下面这样几个：

![](https://static001.geekbang.org/resource/image/cd/d1/cd0aae4a0758ac0913ad28988a6718d1.jpg)

为什么默认允许拦截的是这样几个类的方法呢？

MyBatis 底层是通过 Executor 类来执行 SQL 的。Executor 类会创建 StatementHandler、ParameterHandler、ResultSetHandler 三个对象，并且，首先使用 ParameterHandler 设置 SQL 中的占位符参数，然后使用 StatementHandler 执行 SQL 语句，最后使用 ResultSetHandler 封装执行结果。所以，我们只需要拦截 Executor、ParameterHandler、ResultSetHandler、StatementHandler 这几个类的方法，基本上就能满足我们对整个 SQL 执行流程的拦截了。

实际上，除了统计 SQL 的执行耗时，利用 MyBatis Plugin，我们还可以做很多事情，比如分库分表、自动分页、数据脱敏、加密解密等等。如果感兴趣的话，你可以自己实现一下。

## MyBatis Plugin 的设计与实现

刚刚我们简单介绍了 MyBatis Plugin 是如何使用的。现在，我们再剖析一下源码，看看如此简洁的使用方式，底层是如何实现的，隐藏了哪些复杂的设计。

相对于 Servlet Filter、Spring Interceptor 中职责链模式的代码实现，MyBatis Plugin 的代码实现还是蛮有技巧的，因为它是借助动态代理来实现职责链的。

在[第 62 节](undefined)和[第 63 节](undefined)中，我们讲到，职责链模式的实现一般包含处理器（Handler）和处理器链（HandlerChain）两部分。这两个部分对应到 Servlet Filter 的源码就是 Filter 和 FilterChain，对应到 Spring Interceptor 的源码就是 HandlerInterceptor 和 HandlerExecutionChain，对应到 MyBatis Plugin 的源码就是 Interceptor 和 InterceptorChain。除此之外，MyBatis Plugin 还包含另外一个非常重要的类：Plugin。它用来生成被拦截对象的动态代理。

集成了 MyBatis 的应用在启动的时候，MyBatis 框架会读取全局配置文件（前面例子中的 mybatis-config.xml 文件），解析出 Interceptor（也就是例子中的 SqlCostTimeInterceptor），并且将它注入到 Configuration 类的 InterceptorChain 对象中。这部分逻辑对应到源码如下所示：

public class XMLConfigBuilder extends BaseBuilder {

  //解析配置

  private void parseConfiguration(XNode root) {

​    try {

​     //省略部分代码...

​      pluginElement(root.evalNode("plugins")); //解析插件

​    } catch (Exception e) {

​      throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + e, e);

​    }

  }

  //解析插件

   private void pluginElement(XNode parent) throws Exception {

​    if (parent != null) {

​      for (XNode child : parent.getChildren()) {

​        String interceptor = child.getStringAttribute("interceptor");

​        Properties properties = child.getChildrenAsProperties();

​        //创建Interceptor类对象

​        Interceptor interceptorInstance = (Interceptor) resolveClass(interceptor).newInstance();

​        //调用Interceptor上的setProperties()方法设置properties

​        interceptorInstance.setProperties(properties);

​        //下面这行代码会调用InterceptorChain.addInterceptor()方法

​        configuration.addInterceptor(interceptorInstance);

​      }

​    }

  }

}

// Configuration类的addInterceptor()方法的代码如下所示

public void addInterceptor(Interceptor interceptor) {

  interceptorChain.addInterceptor(interceptor);

}

我们再来看 Interceptor 和 InterceptorChain 这两个类的代码，如下所示。Interceptor 的 setProperties() 方法就是一个单纯的 setter 方法，主要是为了方便通过配置文件配置 Interceptor 的一些属性值，没有其他作用。Interceptor 类中 intecept() 和 plugin() 函数，以及 InterceptorChain 类中的 pluginAll() 函数，是最核心的三个函数，我们待会再详细解释。

public class Invocation {

  private final Object target;

  private final Method method;

  private final Object[] args;

  // 省略构造函数和getter方法...

  public Object proceed() throws InvocationTargetException, IllegalAccessException {

​    return method.invoke(target, args);

  }

}

public interface Interceptor {

  Object intercept(Invocation invocation) throws Throwable;

  Object plugin(Object target);

  void setProperties(Properties properties);

}

public class InterceptorChain {

  private final List<Interceptor> interceptors = new ArrayList<Interceptor>();

  public Object pluginAll(Object target) {

​    for (Interceptor interceptor : interceptors) {

​      target = interceptor.plugin(target);

​    }

​    return target;

  }

  public void addInterceptor(Interceptor interceptor) {

​    interceptors.add(interceptor);

  }

  

  public List<Interceptor> getInterceptors() {

​    return Collections.unmodifiableList(interceptors);

  }

}

解析完配置文件之后，所有的 Interceptor 都加载到了 InterceptorChain 中。接下来，我们再来看下，这些拦截器是在什么时候被触发执行的？又是如何被触发执行的呢？

前面我们提到，在执行 SQL 的过程中，MyBatis 会创建 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这几个类的对象，对应的创建代码在 Configuration 类中，如下所示：

public Executor newExecutor(Transaction transaction, ExecutorType executorType) {

  executorType = executorType == null ? defaultExecutorType : executorType;

  executorType = executorType == null ? ExecutorType.SIMPLE : executorType;

  Executor executor;

  if (ExecutorType.BATCH == executorType) {

​    executor = new BatchExecutor(this, transaction);

  } else if (ExecutorType.REUSE == executorType) {

​    executor = new ReuseExecutor(this, transaction);

  } else {

​    executor = new SimpleExecutor(this, transaction);

  }

  if (cacheEnabled) {

​    executor = new CachingExecutor(executor);

  }

  executor = (Executor) interceptorChain.pluginAll(executor);

  return executor;

}

public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {

  ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);

  parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);

  return parameterHandler;

}

public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler,

​    ResultHandler resultHandler, BoundSql boundSql) {

  ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);

  resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);

  return resultSetHandler;

}

public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {

  StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);

  statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);

  return statementHandler;

}

从上面的代码中，我们可以发现，这几个类对象的创建过程都调用了 InteceptorChain 的 pluginAll() 方法。这个方法的代码前面已经给出了。你可以回过头去再看一眼。它的代码实现很简单，嵌套调用 InterceptorChain 上每个 Interceptor 的 plugin() 方法。plugin() 是一个接口方法（不包含实现代码），需要由用户给出具体的实现代码。在之前的例子中，SQLTimeCostInterceptor 的 plugin() 方法通过直接调用 Plugin 的 wrap() 方法来实现。wrap() 方法的代码实现如下所示：

// 借助Java InvocationHandler实现的动态代理模式

public class Plugin implements InvocationHandler {

  private final Object target;

  private final Interceptor interceptor;

  private final Map<Class<?>, Set<Method>> signatureMap;

  private Plugin(Object target, Interceptor interceptor, Map<Class<?>, Set<Method>> signatureMap) {

​    this.target = target;

​    this.interceptor = interceptor;

​    this.signatureMap = signatureMap;

  }

  // wrap()静态方法，用来生成target的动态代理，

  // 动态代理对象=target对象+interceptor对象。

  public static Object wrap(Object target, Interceptor interceptor) {

​    Map<Class<?>, Set<Method>> signatureMap = getSignatureMap(interceptor);

​    Class<?> type = target.getClass();

​    Class<?>[] interfaces = getAllInterfaces(type, signatureMap);

​    if (interfaces.length > 0) {

​      return Proxy.newProxyInstance(

​          type.getClassLoader(),

​          interfaces,

​          new Plugin(target, interceptor, signatureMap));

​    }

​    return target;

  }

  // 调用target上的f()方法，会触发执行下面这个方法。

  // 这个方法包含：执行interceptor的intecept()方法 + 执行target上f()方法。

  @Override

  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

​    try {

​      Set<Method> methods = signatureMap.get(method.getDeclaringClass());

​      if (methods != null && methods.contains(method)) {

​        return interceptor.intercept(new Invocation(target, method, args));

​      }

​      return method.invoke(target, args);

​    } catch (Exception e) {

​      throw ExceptionUtil.unwrapThrowable(e);

​    }

  }

  private static Map<Class<?>, Set<Method>> getSignatureMap(Interceptor interceptor) {

​    Intercepts interceptsAnnotation = interceptor.getClass().getAnnotation(Intercepts.class);

​    // issue #251

​    if (interceptsAnnotation == null) {

​      throw new PluginException("No @Intercepts annotation was found in interceptor " + interceptor.getClass().getName());      

​    }

​    Signature[] sigs = interceptsAnnotation.value();

​    Map<Class<?>, Set<Method>> signatureMap = new HashMap<Class<?>, Set<Method>>();

​    for (Signature sig : sigs) {

​      Set<Method> methods = signatureMap.get(sig.type());

​      if (methods == null) {

​        methods = new HashSet<Method>();

​        signatureMap.put(sig.type(), methods);

​      }

​      try {

​        Method method = sig.type().getMethod(sig.method(), sig.args());

​        methods.add(method);

​      } catch (NoSuchMethodException e) {

​        throw new PluginException("Could not find method on " + sig.type() + " named " + sig.method() + ". Cause: " + e, e);

​      }

​    }

​    return signatureMap;

  }

  private static Class<?>[] getAllInterfaces(Class<?> type, Map<Class<?>, Set<Method>> signatureMap) {

​    Set<Class<?>> interfaces = new HashSet<Class<?>>();

​    while (type != null) {

​      for (Class<?> c : type.getInterfaces()) {

​        if (signatureMap.containsKey(c)) {

​          interfaces.add(c);

​        }

​      }

​      type = type.getSuperclass();

​    }

​    return interfaces.toArray(new Class<?>[interfaces.size()]);

  }

}

实际上，Plugin 是借助 Java InvocationHandler 实现的动态代理类。用来代理给 target 对象添加 Interceptor 功能。其中，要代理的 target 对象就是 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类的对象。wrap() 静态方法是一个工具函数，用来生成 target 对象的动态代理对象。

当然，只有 interceptor 与 target 互相匹配的时候，wrap() 方法才会返回代理对象，否则就返回 target 对象本身。怎么才算是匹配呢？那就是 interceptor 通过 @Signature 注解要拦截的类包含 target 对象，具体可以参看 wrap() 函数的代码实现（上面一段代码中的第 16~19 行）。

MyBatis 中的职责链模式的实现方式比较特殊。它对同一个目标对象嵌套多次代理（也就是 InteceptorChain 中的 pluginAll() 函数要执行的任务）。每个代理对象（Plugin 对象）代理一个拦截器（Interceptor 对象）功能。为了方便你查看，我将 pluginAll() 函数的代码又拷贝到了下面。

public Object pluginAll(Object target) {

  // 嵌套代理

  for (Interceptor interceptor : interceptors) {

​    target = interceptor.plugin(target);

​    // 上面这行代码等于下面这行代码，target(代理对象)=target(目标对象)+interceptor(拦截器功能)

​    // target = Plugin.wrap(target, interceptor);

  }

  return target;

}

// MyBatis像下面这样创建target(Executor、StatementHandler、ParameterHandler、ResultSetHandler），相当于多次嵌套代理

Object target = interceptorChain.pluginAll(target);

当执行 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类上的某个方法的时候，MyBatis 会嵌套执行每层代理对象（Plugin 对象）上的 invoke() 方法。而 invoke() 方法会先执行代理对象中的 interceptor 的 intecept() 函数，然后再执行被代理对象上的方法。就这样，一层一层地把代理对象上的 intercept() 函数执行完之后，MyBatis 才最终执行那 4 个原始类对象上的方法。

## 重点回顾

好了，今天内容到此就讲完了。我们来一块总结回顾一下，你需要重点掌握的内容。

今天，我们带你剖析了如何利用职责链模式和动态代理模式来实现 MyBatis Plugin。至此，我们就已经学习了三种职责链常用的应用场景：过滤器（Servlet Filter）、拦截器（Spring Interceptor）、插件（MyBatis Plugin）。

职责链模式的实现一般包含处理器和处理器链两部分。这两个部分对应到 Servlet Filter 的源码就是 Filter 和 FilterChain，对应到 Spring Interceptor 的源码就是 HandlerInterceptor 和 HandlerExecutionChain，对应到 MyBatis Plugin 的源码就是 Interceptor 和 InterceptorChain。除此之外，MyBatis Plugin 还包含另外一个非常重要的类：Plugin 类。它用来生成被拦截对象的动态代理。

在这三种应用场景中，职责链模式的实现思路都不大一样。其中，Servlet Filter 采用递归来实现拦截方法前后添加逻辑。Spring Interceptor 的实现比较简单，把拦截方法前后要添加的逻辑放到两个方法中实现。MyBatis Plugin 采用嵌套动态代理的方法来实现，实现思路很有技巧。

## 课堂讨论

Servlet Filter、Spring Interceptor 可以用来拦截用户自己定义的类的方法，而 MyBatis Plugin 默认可以拦截的只有 Executor、StatementHandler、ParameterHandler、ResultSetHandler 这四个类的方法，而且这四个类是 MyBatis 实现的类，并非用户自己定义的类。那 MyBatis Plugin 为什么不像 Servlet Filter、Spring Interceptor 那样，提供拦截用户自定义类的方法的功能呢？

# 89 | 开源实战五（下）：总结MyBatis框架中用到的10种设计模式

王争 2020-05-27

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：13.53M 时长：14:46

上节课，我带你剖析了利用职责链模式和动态代理模式实现 MyBatis Plugin。至此，我们已经学习了三种职责链常用的应用场景：过滤器（Servlet Filter）、拦截器（Spring Interceptor）、插件（MyBatis Plugin）。

今天，我们再对 MyBatis 用到的设计模式做一个总结。它用到的设计模式也不少，就我所知的不下十几种。有些我们前面已经讲到，有些比较简单。有了前面这么多讲的学习和训练，我想你现在应该已经具备了一定的研究和分析能力，能够自己做查缺补漏，把提到的所有源码都搞清楚。所以，在今天的课程中，如果有哪里有疑问，你尽可以去查阅源码，自己先去学习一下，有不懂的地方，再到评论区和大家一起交流。

话不多说，让我们正式开始今天的学习吧！

## SqlSessionFactoryBuilder：为什么要用建造者模式来创建 SqlSessionFactory？

在[第 87 讲](undefined)中，我们通过一个查询用户的例子展示了用 MyBatis 进行数据库编程。为了方便你查看，我把相关的代码重新摘抄到这里。

public class MyBatisDemo {

  public static void main(String[] args) throws IOException {

​    Reader reader = Resources.getResourceAsReader("mybatis.xml");

​    SqlSessionFactory sessionFactory = new SqlSessionFactoryBuilder().build(reader);

​    SqlSession session = sessionFactory.openSession();

​    UserMapper userMapper = session.getMapper(UserMapper.class);

​    UserDo userDo = userMapper.selectById(8);

​    //...

  }

}

针对这段代码，请你思考一下下面这个问题。

之前讲到建造者模式的时候，我们使用 Builder 类来创建对象，一般都是先级联一组 setXXX() 方法来设置属性，然后再调用 build() 方法最终创建对象。但是，在上面这段代码中，通过 SqlSessionFactoryBuilder 来创建 SqlSessionFactory 并不符合这个套路。它既没有 setter 方法，而且 build() 方法也并非无参，需要传递参数。除此之外，从上面的代码来看，SqlSessionFactory 对象的创建过程也并不复杂。那直接通过构造函数来创建 SqlSessionFactory 不就行了吗？为什么还要借助建造者模式创建 SqlSessionFactory 呢？

要回答这个问题，我们就要先看下 SqlSessionFactoryBuilder 类的源码。我把源码摘抄到了这里，如下所示：

public class SqlSessionFactoryBuilder {

  public SqlSessionFactory build(Reader reader) {

​    return build(reader, null, null);

  }

  public SqlSessionFactory build(Reader reader, String environment) {

​    return build(reader, environment, null);

  }

  public SqlSessionFactory build(Reader reader, Properties properties) {

​    return build(reader, null, properties);

  }

  public SqlSessionFactory build(Reader reader, String environment, Properties properties) {

​    try {

​      XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties);

​      return build(parser.parse());

​    } catch (Exception e) {

​      throw ExceptionFactory.wrapException("Error building SqlSession.", e);

​    } finally {

​      ErrorContext.instance().reset();

​      try {

​        reader.close();

​      } catch (IOException e) {

​        // Intentionally ignore. Prefer previous error.

​      }

​    }

  }

  public SqlSessionFactory build(InputStream inputStream) {

​    return build(inputStream, null, null);

  }

  public SqlSessionFactory build(InputStream inputStream, String environment) {

​    return build(inputStream, environment, null);

  }

  public SqlSessionFactory build(InputStream inputStream, Properties properties) {

​    return build(inputStream, null, properties);

  }

  public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties) {

​    try {

​      XMLConfigBuilder parser = new XMLConfigBuilder(inputStream, environment, properties);

​      return build(parser.parse());

​    } catch (Exception e) {

​      throw ExceptionFactory.wrapException("Error building SqlSession.", e);

​    } finally {

​      ErrorContext.instance().reset();

​      try {

​        inputStream.close();

​      } catch (IOException e) {

​        // Intentionally ignore. Prefer previous error.

​      }

​    }

  }

​    

  public SqlSessionFactory build(Configuration config) {

​    return new DefaultSqlSessionFactory(config);

  }

}

SqlSessionFactoryBuilder 类中有大量的 build() 重载函数。为了方便你查看，以及待会儿跟 SqlSessionFactory 类的代码作对比，我把重载函数定义抽象出来，贴到这里。

public class SqlSessionFactoryBuilder {

  public SqlSessionFactory build(Reader reader);

  public SqlSessionFactory build(Reader reader, String environment);

  public SqlSessionFactory build(Reader reader, Properties properties);

  public SqlSessionFactory build(Reader reader, String environment, Properties properties);

  

  public SqlSessionFactory build(InputStream inputStream);

  public SqlSessionFactory build(InputStream inputStream, String environment);

  public SqlSessionFactory build(InputStream inputStream, Properties properties);

  public SqlSessionFactory build(InputStream inputStream, String environment, Properties properties);

  // 上面所有的方法最终都调用这个方法    

  public SqlSessionFactory build(Configuration config);

}

我们知道，如果一个类包含很多成员变量，而构建对象并不需要设置所有的成员变量，只需要选择性地设置其中几个就可以。为了满足这样的构建需求，我们就要定义多个包含不同参数列表的构造函数。为了避免构造函数过多、参数列表过长，我们一般通过无参构造函数加 setter 方法或者通过建造者模式来解决。

从建造者模式的设计初衷上来看，SqlSessionFactoryBuilder 虽然带有 Builder 后缀，但不要被它的名字所迷惑，它并不是标准的建造者模式。一方面，原始类 SqlSessionFactory 的构建只需要一个参数，并不复杂。另一方面，Builder 类 SqlSessionFactoryBuilder 仍然定义了 n 多包含不同参数列表的构造函数。

实际上，SqlSessionFactoryBuilder 设计的初衷只不过是为了简化开发。因为构建 SqlSessionFactory 需要先构建 Configuration，而构建 Configuration 是非常复杂的，需要做很多工作，比如配置的读取、解析、创建 n 多对象等。为了将构建 SqlSessionFactory 的过程隐藏起来，对程序员透明，MyBatis 就设计了 SqlSessionFactoryBuilder 类封装这些构建细节。

## SqlSessionFactory：到底属于工厂模式还是建造器模式？

在刚刚那段 MyBatis 示例代码中，我们通过 SqlSessionFactoryBuilder 创建了 SqlSessionFactory，然后再通过 SqlSessionFactory 创建了 SqlSession。刚刚我们讲了 SqlSessionFactoryBuilder，现在我们再来看下 SqlSessionFactory。

从名字上，你可能已经猜到，SqlSessionFactory 是一个工厂类，用到的设计模式是工厂模式。不过，它跟 SqlSessionFactoryBuilder 类似，名字有很大的迷惑性。实际上，它也并不是标准的工厂模式。为什么这么说呢？我们先来看下 SqlSessionFactory 类的源码。

public interface SqlSessionFactory {

  SqlSession openSession();

  SqlSession openSession(boolean autoCommit);

  SqlSession openSession(Connection connection);

  SqlSession openSession(TransactionIsolationLevel level);

  SqlSession openSession(ExecutorType execType);

  SqlSession openSession(ExecutorType execType, boolean autoCommit);

  SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level);

  SqlSession openSession(ExecutorType execType, Connection connection);

  Configuration getConfiguration();

}

SqlSessionFactory 是一个接口，DefaultSqlSessionFactory 是它唯一的实现类。DefaultSqlSessionFactory 源码如下所示：

public class DefaultSqlSessionFactory implements SqlSessionFactory {

  private final Configuration configuration;

  public DefaultSqlSessionFactory(Configuration configuration) {

​    this.configuration = configuration;

  }

  @Override

  public SqlSession openSession() {

​    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, false);

  }

  @Override

  public SqlSession openSession(boolean autoCommit) {

​    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, autoCommit);

  }

  @Override

  public SqlSession openSession(ExecutorType execType) {

​    return openSessionFromDataSource(execType, null, false);

  }

  @Override

  public SqlSession openSession(TransactionIsolationLevel level) {

​    return openSessionFromDataSource(configuration.getDefaultExecutorType(), level, false);

  }

  @Override

  public SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level) {

​    return openSessionFromDataSource(execType, level, false);

  }

  @Override

  public SqlSession openSession(ExecutorType execType, boolean autoCommit) {

​    return openSessionFromDataSource(execType, null, autoCommit);

  }

  @Override

  public SqlSession openSession(Connection connection) {

​    return openSessionFromConnection(configuration.getDefaultExecutorType(), connection);

  }

  @Override

  public SqlSession openSession(ExecutorType execType, Connection connection) {

​    return openSessionFromConnection(execType, connection);

  }

  @Override

  public Configuration getConfiguration() {

​    return configuration;

  }

  private SqlSession openSessionFromDataSource(ExecutorType execType, TransactionIsolationLevel level, boolean autoCommit) {

​    Transaction tx = null;

​    try {

​      final Environment environment = configuration.getEnvironment();

​      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);

​      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);

​      final Executor executor = configuration.newExecutor(tx, execType);

​      return new DefaultSqlSession(configuration, executor, autoCommit);

​    } catch (Exception e) {

​      closeTransaction(tx); // may have fetched a connection so lets call close()

​      throw ExceptionFactory.wrapException("Error opening session.  Cause: " + e, e);

​    } finally {

​      ErrorContext.instance().reset();

​    }

  }

  private SqlSession openSessionFromConnection(ExecutorType execType, Connection connection) {

​    try {

​      boolean autoCommit;

​      try {

​        autoCommit = connection.getAutoCommit();

​      } catch (SQLException e) {

​        // Failover to true, as most poor drivers

​        // or databases won't support transactions

​        autoCommit = true;

​      }      

​      final Environment environment = configuration.getEnvironment();

​      final TransactionFactory transactionFactory = getTransactionFactoryFromEnvironment(environment);

​      final Transaction tx = transactionFactory.newTransaction(connection);

​      final Executor executor = configuration.newExecutor(tx, execType);

​      return new DefaultSqlSession(configuration, executor, autoCommit);

​    } catch (Exception e) {

​      throw ExceptionFactory.wrapException("Error opening session.  Cause: " + e, e);

​    } finally {

​      ErrorContext.instance().reset();

​    }

  }

  //...省略部分代码...

}

从 SqlSessionFactory 和 DefaultSqlSessionFactory 的源码来看，它的设计非常类似刚刚讲到的 SqlSessionFactoryBuilder，通过重载多个 openSession() 函数，支持通过组合 autoCommit、Executor、Transaction 等不同参数，来创建 SqlSession 对象。标准的工厂模式通过 type 来创建继承同一个父类的不同子类对象，而这里只不过是通过传递进不同的参数，来创建同一个类的对象。所以，它更像建造者模式。

虽然设计思路基本一致，但一个叫 xxxBuilder（SqlSessionFactoryBuilder），一个叫 xxxFactory（SqlSessionFactory）。而且，叫 xxxBuilder 的也并非标准的建造者模式，叫 xxxFactory 的也并非标准的工厂模式。所以，我个人觉得，MyBatis 对这部分代码的设计还是值得优化的。

实际上，这两个类的作用只不过是为了创建 SqlSession 对象，没有其他作用。所以，我更建议参照 Spring 的设计思路，把 SqlSessionFactoryBuilder 和 SqlSessionFactory 的逻辑，放到一个叫“ApplicationContext”的类中。让这个类来全权负责读入配置文件，创建 Congfiguration，生成 SqlSession。

## BaseExecutor：模板模式跟普通的继承有什么区别？

如果去查阅 SqlSession 与 DefaultSqlSession 的源码，你会发现，SqlSession 执行 SQL 的业务逻辑，都是委托给了 Executor 来实现。Executor 相关的类主要是用来执行 SQL。其中，Executor 本身是一个接口；BaseExecutor 是一个抽象类，实现了 Executor 接口；而 BatchExecutor、SimpleExecutor、ReuseExecutor 三个类继承 BaseExecutor 抽象类。

那 BatchExecutor、SimpleExecutor、ReuseExecutor 三个类跟 BaseExecutor 是简单的继承关系，还是模板模式关系呢？怎么来判断呢？我们看一下 BaseExecutor 的源码就清楚了。

public abstract class BaseExecutor implements Executor {

  //...省略其他无关代码...

  

  @Override

  public int update(MappedStatement ms, Object parameter) throws SQLException {

​    ErrorContext.instance().resource(ms.getResource()).activity("executing an update").object(ms.getId());

​    if (closed) {

​      throw new ExecutorException("Executor was closed.");

​    }

​    clearLocalCache();

​    return doUpdate(ms, parameter);

  }

  public List<BatchResult> flushStatements(boolean isRollBack) throws SQLException {

​    if (closed) {

​      throw new ExecutorException("Executor was closed.");

​    }

​    return doFlushStatements(isRollBack);

  }

  private <E> List<E> queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {

​    List<E> list;

​    localCache.putObject(key, EXECUTION_PLACEHOLDER);

​    try {

​      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);

​    } finally {

​      localCache.removeObject(key);

​    }

​    localCache.putObject(key, list);

​    if (ms.getStatementType() == StatementType.CALLABLE) {

​      localOutputParameterCache.putObject(key, parameter);

​    }

​    return list;

  }

  @Override

  public <E> Cursor<E> queryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds) throws SQLException {

​    BoundSql boundSql = ms.getBoundSql(parameter);

​    return doQueryCursor(ms, parameter, rowBounds, boundSql);

  }

  protected abstract int doUpdate(MappedStatement ms, Object parameter) throws SQLException;

  protected abstract List<BatchResult> doFlushStatements(boolean isRollback) throws SQLException;

  protected abstract <E> List<E> doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException;

  protected abstract <E> Cursor<E> doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql) throws SQLException;

}

模板模式基于继承来实现代码复用。如果抽象类中包含模板方法，模板方法调用有待子类实现的抽象方法，那这一般就是模板模式的代码实现。而且，在命名上，模板方法与抽象方法一般是一一对应的，抽象方法在模板方法前面多一个“do”，比如，在 BaseExecutor 类中，其中一个模板方法叫 update()，那对应的抽象方法就叫 doUpdate()。

## SqlNode：如何利用解释器模式来解析动态 SQL？

支持配置文件中编写动态 SQL，是 MyBatis 一个非常强大的功能。所谓动态 SQL，就是在 SQL 中可以包含在 trim、if、#{}等语法标签，在运行时根据条件来生成不同的 SQL。这么说比较抽象，我举个例子解释一下。

<update id="update" parameterType="com.xzg.cd.a89.User"

   UPDATE user

   <trim prefix="SET" prefixOverrides=",">

​       <if test="name != null and name != ''">

​           name = #{name}

​       </if>

​       <if test="age != null and age != ''">

​           , age = #{age}

​       </if>

​       <if test="birthday != null and birthday != ''">

​           , birthday = #{birthday}

​       </if>

   </trim>

   where id = ${id}

</update>

显然，动态 SQL 的语法规则是 MyBatis 自定义的。如果想要根据语法规则，替换掉动态 SQL 中的动态元素，生成真正可以执行的 SQL 语句，MyBatis 还需要实现对应的解释器。这一部分功能就可以看做是解释器模式的应用。实际上，如果你去查看它的代码实现，你会发现，它跟我们在前面讲解释器模式时举的那两个例子的代码结构非常相似。

我们前面提到，解释器模式在解释语法规则的时候，一般会把规则分割成小的单元，特别是可以嵌套的小单元，针对每个小单元来解析，最终再把解析结果合并在一起。这里也不例外。MyBatis 把每个语法小单元叫 SqlNode。SqlNode 的定义如下所示：

public interface SqlNode {

 boolean apply(DynamicContext context);

}

对于不同的语法小单元，MyBatis 定义不同的 SqlNode 实现类。

![](https://static001.geekbang.org/resource/image/03/9f/0365945b91a00e3b98d0c09b2665f59f.png)

整个解释器的调用入口在 DynamicSqlSource.getBoundSql 方法中，它调用了 rootSqlNode.apply(context) 方法。因为整体的代码结构跟[第 72 讲](undefined)中的例子基本一致，所以每个 SqlNode 实现类的代码，我就不带你一块阅读了，感兴趣的话你可以自己去看下。

## ErrorContext：如何实现一个线程唯一的单例模式？

在单例模式那一部分我们讲到，单例模式是进程唯一的。同时，我们还讲到单例模式的几种变形，比如线程唯一的单例、集群唯一的单例等。在 MyBatis 中，ErrorContext 这个类就是标准单例的变形：线程唯一的单例。

它的代码实现我贴到下面了。它基于 Java 中的 ThreadLocal 来实现。如果不熟悉 ThreadLocal，你可以回过头去看下[第 43 讲](undefined)中线程唯一的单例的实现方法。实际上，这里的 ThreadLocal 就相当于那里的 ConcurrentHashMap。

public class ErrorContext {

  private static final String LINE_SEPARATOR = System.getProperty("line.separator","\n");

  private static final ThreadLocal<ErrorContext> LOCAL = new ThreadLocal<ErrorContext>();

  private ErrorContext stored;

  private String resource;

  private String activity;

  private String object;

  private String message;

  private String sql;

  private Throwable cause;

  private ErrorContext() {

  }

  public static ErrorContext instance() {

​    ErrorContext context = LOCAL.get();

​    if (context == null) {

​      context = new ErrorContext();

​      LOCAL.set(context);

​    }

​    return context;

  }

}

## Cache：为什么要用装饰器模式而不设计成继承子类？

我们前面提到，MyBatis 是一个 ORM 框架。实际上，它不只是简单地完成了对象和数据库数据之间的互相转化，还提供了很多其他功能，比如缓存、事务等。接下来，我们再讲讲它的缓存实现。

在 MyBatis 中，缓存功能由接口 Cache 定义。PerpetualCache 类是最基础的缓存类，是一个大小无限的缓存。除此之外，MyBatis 还设计了 9 个包裹 PerpetualCache 类的装饰器类，用来实现功能增强。它们分别是：FifoCache、LoggingCache、LruCache、ScheduledCache、SerializedCache、SoftCache、SynchronizedCache、WeakCache、TransactionalCache。

public interface Cache {

  String getId();

  void putObject(Object key, Object value);

  Object getObject(Object key);

  Object removeObject(Object key);

  void clear();

  int getSize();

  ReadWriteLock getReadWriteLock();

}

public class PerpetualCache implements Cache {

  private final String id;

  private Map<Object, Object> cache = new HashMap<Object, Object>();

  public PerpetualCache(String id) {

​    this.id = id;

  }

  @Override

  public String getId() {

​    return id;

  }

  @Override

  public int getSize() {

​    return cache.size();

  }

  @Override

  public void putObject(Object key, Object value) {

​    cache.put(key, value);

  }

  @Override

  public Object getObject(Object key) {

​    return cache.get(key);

  }

  @Override

  public Object removeObject(Object key) {

​    return cache.remove(key);

  }

  @Override

  public void clear() {

​    cache.clear();

  }

  @Override

  public ReadWriteLock getReadWriteLock() {

​    return null;

  }

  //省略部分代码...

}

这 9 个装饰器类的代码结构都类似，我只将其中的 LruCache 的源码贴到这里。从代码中我们可以看出，它是标准的装饰器模式的代码实现。

public class LruCache implements Cache {

  private final Cache delegate;

  private Map<Object, Object> keyMap;

  private Object eldestKey;

  public LruCache(Cache delegate) {

​    this.delegate = delegate;

​    setSize(1024);

  }

  @Override

  public String getId() {

​    return delegate.getId();

  }

  @Override

  public int getSize() {

​    return delegate.getSize();

  }

  public void setSize(final int size) {

​    keyMap = new LinkedHashMap<Object, Object>(size, .75F, true) {

​      private static final long serialVersionUID = 4267176411845948333L;

​      @Override

​      protected boolean removeEldestEntry(Map.Entry<Object, Object> eldest) {

​        boolean tooBig = size() > size;

​        if (tooBig) {

​          eldestKey = eldest.getKey();

​        }

​        return tooBig;

​      }

​    };

  }

  @Override

  public void putObject(Object key, Object value) {

​    delegate.putObject(key, value);

​    cycleKeyList(key);

  }

  @Override

  public Object getObject(Object key) {

​    keyMap.get(key); //touch

​    return delegate.getObject(key);

  }

  @Override

  public Object removeObject(Object key) {

​    return delegate.removeObject(key);

  }

  @Override

  public void clear() {

​    delegate.clear();

​    keyMap.clear();

  }

  @Override

  public ReadWriteLock getReadWriteLock() {

​    return null;

  }

  private void cycleKeyList(Object key) {

​    keyMap.put(key, key);

​    if (eldestKey != null) {

​      delegate.removeObject(eldestKey);

​      eldestKey = null;

​    }

  }

}

之所以 MyBatis 采用装饰器模式来实现缓存功能，是因为装饰器模式采用了组合，而非继承，更加灵活，能够有效地避免继承关系的组合爆炸。关于这一点，你可以回过头去看下[第 10 讲](undefined)的内容。

## PropertyTokenizer：如何利用迭代器模式实现一个属性解析器？

前面我们讲到，迭代器模式常用来替代 for 循环遍历集合元素。Mybatis 的 PropertyTokenizer 类实现了 Java Iterator 接口，是一个迭代器，用来对配置属性进行解析。具体的代码如下所示：

// person[0].birthdate.year 会被分解为3个PropertyTokenizer对象。其中，第一个PropertyTokenizer对象的各个属性值如注释所示。

public class PropertyTokenizer implements Iterator<PropertyTokenizer> {

  private String name; // person

  private final String indexedName; // person[0]

  private String index; // 0

  private final String children; // birthdate.year

  public PropertyTokenizer(String fullname) {

​    int delim = fullname.indexOf('.');

​    if (delim > -1) {

​      name = fullname.substring(0, delim);

​      children = fullname.substring(delim + 1);

​    } else {

​      name = fullname;

​      children = null;

​    }

​    indexedName = name;

​    delim = name.indexOf('[');

​    if (delim > -1) {

​      index = name.substring(delim + 1, name.length() - 1);

​      name = name.substring(0, delim);

​    }

  }

  public String getName() {

​    return name;

  }

  public String getIndex() {

​    return index;

  }

  public String getIndexedName() {

​    return indexedName;

  }

  public String getChildren() {

​    return children;

  }

  @Override

  public boolean hasNext() {

​    return children != null;

  }

  @Override

  public PropertyTokenizer next() {

​    return new PropertyTokenizer(children);

  }

  @Override

  public void remove() {

​    throw new UnsupportedOperationException("Remove is not supported, as it has no meaning in the context of properties.");

  }

}

实际上，PropertyTokenizer 类也并非标准的迭代器类。它将配置的解析、解析之后的元素、迭代器，这三部分本该放到三个类中的代码，都耦合在一个类中，所以看起来稍微有点难懂。不过，这样做的好处是能够做到惰性解析。我们不需要事先将整个配置，解析成多个 PropertyTokenizer 对象。只有当我们在调用 next() 函数的时候，才会解析其中部分配置。

## Log：如何使用适配器模式来适配不同的日志框架？

在适配器模式那节课中我们讲过，Slf4j 框架为了统一各个不同的日志框架（Log4j、JCL、Logback 等），提供了一套统一的日志接口。不过，MyBatis 并没有直接使用 Slf4j 提供的统一日志规范，而是自己又重复造轮子，定义了一套自己的日志访问接口。

public interface Log {

  boolean isDebugEnabled();

  boolean isTraceEnabled();

  void error(String s, Throwable e);

  void error(String s);

  void debug(String s);

  void trace(String s);

  void warn(String s);

}

针对 Log 接口，MyBatis 还提供了各种不同的实现类，分别使用不同的日志框架来实现 Log 接口。

![](https://static001.geekbang.org/resource/image/95/14/95946f9e9c524cc06279114f7a654f14.png)

这几个实现类的代码结构基本上一致。我把其中的 Log4jImpl 的源码贴到了这里。我们知道，在适配器模式中，传递给适配器构造函数的是被适配的类对象，而这里是 clazz（相当于日志名称 name），所以，从代码实现上来讲，它并非标准的适配器模式。但是，从应用场景上来看，这里确实又起到了适配的作用，是典型的适配器模式的应用场景。

import org.apache.ibatis.logging.Log;

import org.apache.log4j.Level;

import org.apache.log4j.Logger;

public class Log4jImpl implements Log {

  private static final String FQCN = Log4jImpl.class.getName();

  private final Logger log;

  public Log4jImpl(String clazz) {

​    log = Logger.getLogger(clazz);

  }

  @Override

  public boolean isDebugEnabled() {

​    return log.isDebugEnabled();

  }

  @Override

  public boolean isTraceEnabled() {

​    return log.isTraceEnabled();

  }

  @Override

  public void error(String s, Throwable e) {

​    log.log(FQCN, Level.ERROR, s, e);

  }

  @Override

  public void error(String s) {

​    log.log(FQCN, Level.ERROR, s, null);

  }

  @Override

  public void debug(String s) {

​    log.log(FQCN, Level.DEBUG, s, null);

  }

  @Override

  public void trace(String s) {

​    log.log(FQCN, Level.TRACE, s, null);

  }

  @Override

  public void warn(String s) {

​    log.log(FQCN, Level.WARN, s, null);

  }

}

## 重点回顾

好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。

今天，我们讲到了 MyBatis 中用到的 8 种设计模式，它们分别是：建造者模式、工厂模式、模板模式、解释器模式、单例模式、装饰器模式、迭代器模式、适配器模式。加上上一节课中讲到的职责链和动态代理，我们总共讲了 10 种设计模式。

还是那句老话，你不需要记忆哪个类用到了哪个模式，因为不管你看多少遍，甚至记住并没有什么用。我希望你不仅仅只是把文章看了，更希望你能动手把 MyBatis 源码下载下来，自己去阅读一下相关的源码，锻炼自己阅读源码的能力。这比单纯看文章效果要好很多倍。

除此之外，从这两节课的讲解中，不知道你有没有发现，MyBatis 对很多设计模式的实现，都并非标准的代码实现，都做了比较多的自我改进。实际上，这就是所谓的灵活应用，只借鉴不照搬，根据具体问题针对性地去解决。

## 课堂讨论

今天我们提到，SqlSessionFactoryBuilder 跟 SqlSessionFactory 虽然名字后缀不同，但是设计思路一致，都是为了隐藏 SqlSession 的创建细节。从这一点上来看，命名有点不够统一。而且，我们还提到，SqlSessionFactoryBuilder 并非标准的建造者模式，SqlSessionFactory 也并非标准的工厂模式。对此你有什么看法呢？

