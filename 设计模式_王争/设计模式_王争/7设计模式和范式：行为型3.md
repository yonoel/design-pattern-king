# 68 | 访问者模式（上）：手把手带你还原访问者模式诞生的思维过程

王争 2020-04-08

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：8.41M 时长：09:10

前面我们讲到，大部分设计模式的原理和实现都很简单，不过也有例外，比如今天要讲的访问者模式。它可以算是 23 种经典设计模式中最难理解的几个之一。因为它难理解、难实现，应用它会导致代码的可读性、可维护性变差，所以，访问者模式在实际的软件开发中很少被用到，在没有特别必要的情况下，建议你不要使用访问者模式。

尽管如此，为了让你以后读到应用了访问者模式的代码的时候，能一眼就能看出代码的设计意图，同时为了整个专栏内容的完整性，我觉得还是有必要给你讲一讲这个模式。除此之外，为了最大化学习效果，我今天不只是单纯地讲解原理和实现，更重要的是，我会手把手带你还原访问者模式诞生的思维过程，让你切身感受到创造一种新的设计模式出来并不是件难事。

话不多说，让我们正式开始今天的学习吧！

## 带你“发明”访问者模式

假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，把这些资源文件中的文本内容抽取出来放到 txt 文件中。如果让你来实现，你会怎么来做呢？

实现这个功能并不难，不同的人有不同的写法，我将其中一种代码实现方式贴在这里。其中，ResourceFile 是一个抽象类，包含一个抽象函数 extract2txt()。PdfFile、PPTFile、WordFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在 ToolApplication 中，我们可以利用多态特性，根据对象的实际类型，来决定执行哪个方法。

public abstract class ResourceFile {

  protected String filePath;

  public ResourceFile(String filePath) {

​    this.filePath = filePath;

  }

  public abstract void extract2txt();

}

public class PPTFile extends ResourceFile {

  public PPTFile(String filePath) {

​    super(filePath);

  }

  @Override

  public void extract2txt() {

​    //...省略一大坨从PPT中抽取文本的代码...

​    //...将抽取出来的文本保存在跟filePath同名的.txt文件中...

​    System.out.println("Extract PPT.");

  }

}

public class PdfFile extends ResourceFile {

  public PdfFile(String filePath) {

​    super(filePath);

  }

  @Override

  public void extract2txt() {

​    //...

​    System.out.println("Extract PDF.");

  }

}

public class WordFile extends ResourceFile {

  public WordFile(String filePath) {

​    super(filePath);

  }

  @Override

  public void extract2txt() {

​    //...

​    System.out.println("Extract WORD.");

  }

}

// 运行结果是：

// Extract PDF.

// Extract WORD.

// Extract PPT.

public class ToolApplication {

  public static void main(String[] args) {

​    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);

​    for (ResourceFile resourceFile : resourceFiles) {

​      resourceFile.extract2txt();

​    }

  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {

​    List<ResourceFile> resourceFiles = new ArrayList<>();

​    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)

​    resourceFiles.add(new PdfFile("a.pdf"));

​    resourceFiles.add(new WordFile("b.word"));

​    resourceFiles.add(new PPTFile("c.ppt"));

​    return resourceFiles;

  }

}

如果工具的功能不停地扩展，不仅要能抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列的功能，那如果我们继续按照上面的实现思路，就会存在这样几个问题：

违背开闭原则，添加一个新的功能，所有类的代码都要修改；

虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；

把所有比较上层的业务逻辑都耦合到 PdfFile、PPTFile、WordFile 类中，导致这些类的职责不够单一，变成了大杂烩。

针对上面的问题，我们常用的解决方法就是拆分解耦，把业务操作跟具体的数据结构解耦，设计成独立的类。这里我们按照访问者模式的演进思路来对上面的代码进行重构。重构之后的代码如下所示。

public abstract class ResourceFile {

  protected String filePath;

  public ResourceFile(String filePath) {

​    this.filePath = filePath;

  }

}

public class PdfFile extends ResourceFile {

  public PdfFile(String filePath) {

​    super(filePath);

  }

  //...

}

//...PPTFile、WordFile代码省略...

public class Extractor {

  public void extract2txt(PPTFile pptFile) {

​    //...

​    System.out.println("Extract PPT.");

  }

  public void extract2txt(PdfFile pdfFile) {

​    //...

​    System.out.println("Extract PDF.");

  }

  public void extract2txt(WordFile wordFile) {

​    //...

​    System.out.println("Extract WORD.");

  }

}

public class ToolApplication {

  public static void main(String[] args) {

​    Extractor extractor = new Extractor();

​    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);

​    for (ResourceFile resourceFile : resourceFiles) {

​      extractor.extract2txt(resourceFile);

​    }

  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {

​    List<ResourceFile> resourceFiles = new ArrayList<>();

​    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)

​    resourceFiles.add(new PdfFile("a.pdf"));

​    resourceFiles.add(new WordFile("b.word"));

​    resourceFiles.add(new PPTFile("c.ppt"));

​    return resourceFiles;

  }

}

这其中最关键的一点设计是，我们把抽取文本内容的操作，设计成了三个重载函数。函数重载是 Java、C++ 这类面向对象编程语言中常见的语法机制。所谓重载函数是指，在同一类中函数名相同、参数不同的一组函数。

不过，如果你足够细心，就会发现，上面的代码是编译通过不了的，第 37 行会报错。这是为什么呢？

我们知道，多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法。

在上面代码的第 35～38 行中，resourceFiles 包含的对象的声明类型都是 ResourceFile，而我们并没有在 Extractor 类中定义参数类型是 ResourceFile 的 extract2txt() 重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。那如何解决这个问题呢？

解决的办法稍微有点难理解，我们先来看代码，然后我再来给你慢慢解释。

public abstract class ResourceFile {

  protected String filePath;

  public ResourceFile(String filePath) {

​    this.filePath = filePath;

  }

  abstract public void accept(Extractor extractor);

}

public class PdfFile extends ResourceFile {

  public PdfFile(String filePath) {

​    super(filePath);

  }

  @Override

  public void accept(Extractor extractor) {

​    extractor.extract2txt(this);

  }

  //...

}

//...PPTFile、WordFile跟PdfFile类似，这里就省略了...

//...Extractor代码不变...

public class ToolApplication {

  public static void main(String[] args) {

​    Extractor extractor = new Extractor();

​    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);

​    for (ResourceFile resourceFile : resourceFiles) {

​      resourceFile.accept(extractor);

​    }

  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {

​    List<ResourceFile> resourceFiles = new ArrayList<>();

​    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)

​    resourceFiles.add(new PdfFile("a.pdf"));

​    resourceFiles.add(new WordFile("b.word"));

​    resourceFiles.add(new PPTFile("c.ppt"));

​    return resourceFiles;

  }

}

在执行第 30 行的时候，根据多态特性，程序会调用实际类型的 accept 函数，比如 PdfFile 的 accept 函数，也就是第 16 行代码。而 16 行代码中的 this 类型是 PdfFile 的，在编译的时候就确定了，所以会调用 extractor 的 extract2txt(PdfFile pdfFile) 这个重载函数。这个实现思路是不是很有技巧？这是理解访问者模式的关键所在，也是我之前所说的访问者模式不好理解的原因。

现在，如果要继续添加新的功能，比如前面提到的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件，那我们该如何实现呢？我们需要实现一个类似 Extractor 类的新类 Compressor 类，在其中定义三个重载函数，实现对不同类型资源文件的压缩。除此之外，我们还要在每个资源文件类中定义新的 accept 重载函数。具体的代码如下所示：

public abstract class ResourceFile {

  protected String filePath;

  public ResourceFile(String filePath) {

​    this.filePath = filePath;

  }

  abstract public void accept(Extractor extractor);

  abstract public void accept(Compressor compressor);

}

public class PdfFile extends ResourceFile {

  public PdfFile(String filePath) {

​    super(filePath);

  }

  @Override

  public void accept(Extractor extractor) {

​    extractor.extract2txt(this);

  }

  @Override

  public void accept(Compressor compressor) {

​    compressor.compress(this);

  }

  //...

}

}

//...PPTFile、WordFile跟PdfFile类似，这里就省略了...

//...Extractor代码不变

public class ToolApplication {

  public static void main(String[] args) {

​    Extractor extractor = new Extractor();

​    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);

​    for (ResourceFile resourceFile : resourceFiles) {

​      resourceFile.accept(extractor);

​    }

​    Compressor compressor = new Compressor();

​    for(ResourceFile resourceFile : resourceFiles) {

​      resourceFile.accept(compressor);

​    }

  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {

​    List<ResourceFile> resourceFiles = new ArrayList<>();

​    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)

​    resourceFiles.add(new PdfFile("a.pdf"));

​    resourceFiles.add(new WordFile("b.word"));

​    resourceFiles.add(new PPTFile("c.ppt"));

​    return resourceFiles;

  }

}

上面代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，我们抽象出来一个 Visitor 接口，包含是三个命名非常通用的 visit() 重载函数，分别处理三种不同类型的资源文件。具体做什么业务处理，由实现这个 Visitor 接口的具体的类来决定，比如 Extractor 负责抽取文本内容，Compressor 负责压缩。当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改 ToolApplication 的代码就可以了。

按照这个思路我们可以对代码进行重构，重构之后的代码如下所示：

public abstract class ResourceFile {

  protected String filePath;

  public ResourceFile(String filePath) {

​    this.filePath = filePath;

  }

  abstract public void accept(Visitor vistor);

}

public class PdfFile extends ResourceFile {

  public PdfFile(String filePath) {

​    super(filePath);

  }

  @Override

  public void accept(Visitor visitor) {

​    visitor.visit(this);

  }

  //...

}

//...PPTFile、WordFile跟PdfFile类似，这里就省略了...

public interface Visitor {

  void visit(PdfFile pdfFile);

  void visit(PPTFile pdfFile);

  void visit(WordFile pdfFile);

}

public class Extractor implements Visitor {

  @Override

  public void visit(PPTFile pptFile) {

​    //...

​    System.out.println("Extract PPT.");

  }

  @Override

  public void visit(PdfFile pdfFile) {

​    //...

​    System.out.println("Extract PDF.");

  }

  @Override

  public void visit(WordFile wordFile) {

​    //...

​    System.out.println("Extract WORD.");

  }

}

public class Compressor implements Visitor {

  @Override

  public void visit(PPTFile pptFile) {

​    //...

​    System.out.println("Compress PPT.");

  }

  @Override

  public void visit(PdfFile pdfFile) {

​    //...

​    System.out.println("Compress PDF.");

  }

  @Override

  public void visit(WordFile wordFile) {

​    //...

​    System.out.println("Compress WORD.");

  }

}

public class ToolApplication {

  public static void main(String[] args) {

​    Extractor extractor = new Extractor();

​    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);

​    for (ResourceFile resourceFile : resourceFiles) {

​      resourceFile.accept(extractor);

​    }

​    Compressor compressor = new Compressor();

​    for(ResourceFile resourceFile : resourceFiles) {

​      resourceFile.accept(compressor);

​    }

  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {

​    List<ResourceFile> resourceFiles = new ArrayList<>();

​    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)

​    resourceFiles.add(new PdfFile("a.pdf"));

​    resourceFiles.add(new WordFile("b.word"));

​    resourceFiles.add(new PPTFile("c.ppt"));

​    return resourceFiles;

  }

}

## 重新来看访问者模式

刚刚我带你一步一步还原了访问者模式诞生的思维过程，现在，我们回过头来总结一下，这个模式的原理和代码实现。

访问者者模式的英文翻译是 Visitor Design Pattern。在 GoF 的《设计模式》一书中，它是这么定义的：

Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.

翻译成中文就是：允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。

定义比较简单，结合前面的例子不难理解，我就不过多解释了。对于访问者模式的代码实现，实际上，在上面例子中，经过层层重构之后的最终代码，就是标准的访问者模式的实现代码。这里，我又总结了一张类图，贴在了下面，你可以对照着前面的例子代码一块儿来看一下。

![](https://static001.geekbang.org/resource/image/c4/65/c42c636c5384da5bd5343618305db865.jpg)

最后，我们再来看下，访问者模式的应用场景。

一般来说，访问者模式针对的是一组类型不同的对象（PdfFile、PPTFile、WordFile）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但为了避免不断添加功能导致类（PdfFile、PPTFile、WordFile）不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。

## 重点回顾

好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。

访问者模式允许一个或者多个操作应用到一组对象上，设计意图是解耦操作和对象本身，保持类职责单一、满足开闭原则以及应对代码的复杂性。

对于访问者模式，学习的主要难点在代码实现。而代码实现比较复杂的主要原因是，函数重载在大部分面向对象编程语言中是静态绑定的。也就是说，调用类的哪个重载函数，是在编译期间，由参数的声明类型决定的，而非运行时，根据参数的实际类型决定的。

正是因为代码实现难理解，所以，在项目中应用这种模式，会导致代码的可读性比较差。如果你的同事不了解这种设计模式，可能就会读不懂、维护不了你写的代码。所以，除非不得已，不要使用这种模式。

## 课堂讨论

实际上，今天举的例子不用访问者模式也可以搞定，你能够想到其他实现思路吗？

# 69 | 访问者模式（下）：为什么支持双分派的语言不需要访问者模式？

王争 2020-04-10

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：8.27M 时长：09:01

上一节课中，我们学习了访问者模式的原理和实现，并且还原了访问者模式诞生的思维过程。总体上来讲，这个模式的代码实现比较难，所以应用场景并不多。从应用开发的角度来说，它的确不是我们学习的重点。

不过，我们前面反复说过，学习我的专栏，并不只是让你掌握知识，更重要的是锻炼你分析、解决问题的能力，锻炼你的逻辑思维能力，所以，今天我们继续把访问者模式作为引子，一块讨论一下这样两个问题，希望能激发你的深度思考：

为什么支持双分派的语言不需要访问者模式呢？

除了访问者模式，上一节课中的例子还有其他实现方案吗？

话不多说，让我们正式开始今天的学习吧！

## 为什么支持双分派的语言不需要访问者模式？

实际上，讲到访问者模式，大部分书籍或者资料都会讲到 Double Dispatch，中文翻译为双分派。虽然学习访问者模式，并不用非得理解这个概念，我们前面的讲解就没有提到它，但是，为了让你在查看其它书籍或者资料的时候，不会卡在这个概念上，我觉得有必要在这里讲一下。

除此之外，我觉得，学习 Double Dispatch 还能加深你对访问者模式的理解，而且能一并帮你搞清楚今天文章标题中的这个问题：为什么支持双分派的语言就不需要访问者模式？这个问题在面试中可是会被问到的哦！

既然有 Double Dispatch，对应的就有 Single Dispatch。所谓 Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。所谓 Double Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。

如何理解“Dispatch”这个单词呢？ 在面向对象编程语言中，我们可以把方法调用理解为一种消息传递，也就是“Dispatch”。一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数。

如何理解“Single”“Double”这两个单词呢？“Single”“Double”指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。我们进一步解释一下。Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，只跟“对象”的运行时类型有关。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，跟“对象”和“方法参数”两者的运行时类型有关。

具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。

接下来，我们拿 Java 语言来举例说明一下。

Java 支持多态特性，代码可以在运行时获得对象的实际类型（也就是前面提到的运行时类型），然后根据实际类型决定调用哪个方法。尽管 Java 支持函数重载，但 Java 设计的函数重载的语法规则是，并不是在运行时，根据传递进函数的参数的实际类型，来决定调用哪个重载函数，而是在编译时，根据传递进函数的参数的声明类型（也就是前面提到的编译时类型），来决定调用哪个重载函数。也就是说，具体执行哪个对象的哪个方法，只跟对象的运行时类型有关，跟参数的运行时类型无关。所以，Java 语言只支持 Single Dispatch。

这么说比较抽象，我举个例子来具体说明一下，代码如下所示：

public class ParentClass {

  public void f() {

​    System.out.println("I am ParentClass's f().");

  }

}

public class ChildClass extends ParentClass {

  public void f() {

​    System.out.println("I am ChildClass's f().");

  }

}

public class SingleDispatchClass {

  public void polymorphismFunction(ParentClass p) {

​    p.f();

  }

  public void overloadFunction(ParentClass p) {

​    System.out.println("I am overloadFunction(ParentClass p).");

  }

  public void overloadFunction(ChildClass c) {

​    System.out.println("I am overloadFunction(ChildClass c).");

  }

}

public class DemoMain {

  public static void main(String[] args) {

​    SingleDispatchClass demo = new SingleDispatchClass();

​    ParentClass p = new ChildClass();

​    demo.polymorphismFunction(p);//执行哪个对象的方法，由对象的实际类型决定

​    demo.overloadFunction(p);//执行对象的哪个方法，由参数对象的声明类型决定

  }

}

//代码执行结果:

I am ChildClass's f().

I am overloadFunction(ParentClass p).

在上面的代码中，第 31 行代码的 polymorphismFunction() 函数，执行 p 的实际类型的 f() 函数，也就是 ChildClass 的 f() 函数。第 32 行代码的 overloadFunction() 函数，匹配的是重载函数中的 overloadFunction(ParentClass p)，也就是根据 p 的声明类型来决定匹配哪个重载函数。

假设 Java 语言支持 Double Dispatch，那下面的代码（摘抄自上节课中第二段代码，建议结合上节课的讲解一块理解）中的第 37 行就不会报错。代码会在运行时，根据参数（resourceFile）的实际类型（PdfFile、PPTFile、WordFile），来决定使用 extract2txt 的三个重载函数中的哪一个。那下面的代码实现就能正常运行了，也就不需要访问者模式了。这也回答了为什么支持 Double Dispatch 的语言不需要访问者模式。

public abstract class ResourceFile {

  protected String filePath;

  public ResourceFile(String filePath) {

​    this.filePath = filePath;

  }

}

public class PdfFile extends ResourceFile {

  public PdfFile(String filePath) {

​    super(filePath);

  }

  //...

}

//...PPTFile、WordFile代码省略...

public class Extractor {

  public void extract2txt(PPTFile pptFile) {

​    //...

​    System.out.println("Extract PPT.");

  }

  public void extract2txt(PdfFile pdfFile) {

​    //...

​    System.out.println("Extract PDF.");

  }

  public void extract2txt(WordFile wordFile) {

​    //...

​    System.out.println("Extract WORD.");

  }

}

public class ToolApplication {

  public static void main(String[] args) {

​    Extractor extractor = new Extractor();

​    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);

​    for (ResourceFile resourceFile : resourceFiles) {

​      extractor.extract2txt(resourceFile);

​    }

  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {

​    List<ResourceFile> resourceFiles = new ArrayList<>();

​    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)

​    resourceFiles.add(new PdfFile("a.pdf"));

​    resourceFiles.add(new WordFile("b.word"));

​    resourceFiles.add(new PPTFile("c.ppt"));

​    return resourceFiles;

  }

}

## 除了访问者模式，上一节的例子还有其他实现方案吗？

上节课，我通过一个例子来给你展示了，访问者模式是如何一步一步设计出来的。我们这里再一块回顾一下那个例子。我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、Word。我们要开发一个工具来处理这批资源文件，这其中就包含抽取文本内容、压缩资源文件、提取文件元信息等。

实际上，开发这个工具有很多种代码设计和实现思路。为了讲解访问者模式，上节课我们选择了用访问者模式来实现。实际上，我们还有其他的实现方法，比如，我们还可以利用工厂模式来实现，定义一个包含 extract2txt() 接口函数的 Extractor 接口。PdfExtractor、PPTExtractor、WordExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数中，分别实现 Pdf、PPT、Word 格式文件的文本内容抽取。ExtractorFactory 工厂类根据不同的文件类型，返回不同的 Extractor。

这个实现思路其实更加简单，我们直接看代码。

public abstract class ResourceFile {

  protected String filePath;

  public ResourceFile(String filePath) {

​    this.filePath = filePath;

  }

  public abstract ResourceFileType getType();

}

public class PdfFile extends ResourceFile {

  public PdfFile(String filePath) {

​    super(filePath);

  }

  @Override

  public ResourceFileType getType() {

​    return ResourceFileType.PDF;

  }

  //...

}

//...PPTFile/WordFile跟PdfFile代码结构类似，此处省略...

public interface Extractor {

  void extract2txt(ResourceFile resourceFile);

}

public class PdfExtractor implements Extractor {

  @Override

  public void extract2txt(ResourceFile resourceFile) {

​    //...

  }

}

//...PPTExtractor/WordExtractor跟PdfExtractor代码结构类似，此处省略...

public class ExtractorFactory {

  private static final Map<ResourceFileType, Extractor> extractors = new HashMap<>();

  static {

​    extractors.put(ResourceFileType.PDF, new PdfExtractor());

​    extractors.put(ResourceFileType.PPT, new PPTExtractor());

​    extractors.put(ResourceFileType.WORD, new WordExtractor());

  }

  public static Extractor getExtractor(ResourceFileType type) {

​    return extractors.get(type);

  }

}

public class ToolApplication {

  public static void main(String[] args) {

​    List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);

​    for (ResourceFile resourceFile : resourceFiles) {

​      Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());

​      extractor.extract2txt(resourceFile);

​    }

  }

  private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {

​    List<ResourceFile> resourceFiles = new ArrayList<>();

​    //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)

​    resourceFiles.add(new PdfFile("a.pdf"));

​    resourceFiles.add(new WordFile("b.word"));

​    resourceFiles.add(new PPTFile("c.ppt"));

​    return resourceFiles;

  }

}

当需要添加新的功能的时候，比如压缩资源文件，类似抽取文本内容功能的代码实现，我们只需要添加一个 Compressor 接口，PdfCompressor、PPTCompressor、WordCompressor 三个实现类，以及创建它们的 CompressorFactory 工厂类即可。唯一需要修改的只有最上层的 ToolApplication 类。基本上符合“对扩展开放、对修改关闭”的设计原则。

对于资源文件处理工具这个例子，如果工具提供的功能并不是非常多，只有几个而已，那我更推荐使用工厂模式的实现方式，毕竟代码更加清晰、易懂。相反，如果工具提供非常多的功能，比如有十几个，那我更推荐使用访问者模式，因为访问者模式需要定义的类要比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性。

## 重点回顾

好了，今天内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。

总体上来讲，访问者模式难以理解，应用场景有限，不是特别必需，我不建议在项目中使用它。所以，对于上节课中的处理资源文件的例子，我更推荐使用工厂模式来设计和实现。

除此之外，我们今天重点讲解了 Double Dispatch。在面向对象编程语言中，方法调用可以理解为一种消息传递（Dispatch）。一个对象调用另一个对象的方法，就相当于给它发送一条消息，这条消息起码要包含对象名、方法名和方法参数。

所谓 Single Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。所谓 Double Dispatch，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。

具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch。

## 课堂讨论

访问者模式将操作与对象分离，是否违背面向对象设计原则？你怎么看待这个问题呢？

在解释 Single Dispatch 的代码示例中，如果我们把 SingleDispatchClass 的代码改成下面这样，其他代码不变，那 DemoMain 的输出结果会是什么呢？为什么会是这样的结果呢？

public class SingleDispatchClass {

  public void polymorphismFunction(ParentClass p) {

​    p.f();

  }

  public void overloadFunction(ParentClass p) {

​    p.f();

  }

  public void overloadFunction(ChildClass c) {

​    c.f();

  }

}

# 70 | 备忘录模式：对于大对象的备份和恢复，如何优化内存和时间的消耗？

文章 2020-04-13

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：7.81M 时长：08:31

上两节课，我们学习了访问者模式。在 23 种设计模式中，访问者模式的原理和实现可以说是最难理解的了，特别是它的代码实现。其中，用 Single Dispatch 来模拟 Double Dispatch 的实现思路尤其不好理解。不知道你有没有将它拿下呢？如果还没有弄得很清楚，那就要多看几遍、多自己动脑经琢磨一下。

今天，我们学习另外一种行为型模式，备忘录模式。这个模式理解、掌握起来不难，代码实现比较灵活，应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。所以，相对于上两节课，今天的内容学起来相对会比较轻松些。

话不多说，让我们正式开始今天的学习吧！

## 备忘录模式的原理与实现

备忘录模式，也叫快照（Snapshot）模式，英文翻译是 Memento Design Pattern。在 GoF 的《设计模式》一书中，备忘录模式是这么定义的：

Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.

翻译成中文就是：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。

在我看来，这个模式的定义主要表达了两部分内容。一部分是，存储副本以便后期恢复。这一部分很好理解。另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。这部分不太好理解。接下来，我就结合一个例子来解释一下，特别带你搞清楚这两个问题：

为什么存储和恢复副本会违背封装原则？

备忘录模式是如何做到不违背封装原则的？

假设有这样一道面试题，希望你编写一个小程序，可以接收命令行的输入。用户输入文本时，程序将其追加存储在内存文本中；用户输入“:list”，程序在命令行中输出内存文本的内容；用户输入“:undo”，程序会撤销上一次输入的文本，也就是从内存文本中将上次输入的文本删除掉。

我举了个小例子来解释一下这个需求，如下所示：

\>hello

\>:list

hello

\>world

\>:list

helloworld

\>:undo

\>:list

hello

怎么来编程实现呢？你可以打开 IDE 自己先试着编写一下，然后再看我下面的讲解。整体上来讲，这个小程序实现起来并不复杂。我写了一种实现思路，如下所示：

public class InputText {

  private StringBuilder text = new StringBuilder();

  public String getText() {

​    return text.toString();

  }

  public void append(String input) {

​    text.append(input);

  }

  public void setText(String text) {

​    this.text.replace(0, this.text.length(), text);

  }

}

public class SnapshotHolder {

  private Stack<InputText> snapshots = new Stack<>();

  public InputText popSnapshot() {

​    return snapshots.pop();

  }

  public void pushSnapshot(InputText inputText) {

​    InputText deepClonedInputText = new InputText();

​    deepClonedInputText.setText(inputText.getText());

​    snapshots.push(deepClonedInputText);

  }

}

public class ApplicationMain {

  public static void main(String[] args) {

​    InputText inputText = new InputText();

​    SnapshotHolder snapshotsHolder = new SnapshotHolder();

​    Scanner scanner = new Scanner(System.in);

​    while (scanner.hasNext()) {

​      String input = scanner.next();

​      if (input.equals(":list")) {

​        System.out.println(inputText.getText());

​      } else if (input.equals(":undo")) {

​        InputText snapshot = snapshotsHolder.popSnapshot();

​        inputText.setText(snapshot.getText());

​      } else {

​        snapshotsHolder.pushSnapshot(inputText);

​        inputText.append(input);

​      }

​    }

  }

}

实际上，备忘录模式的实现很灵活，也没有很固定的实现方式，在不同的业务需求、不同编程语言下，代码实现可能都不大一样。上面的代码基本上已经实现了最基本的备忘录的功能。但是，如果我们深究一下的话，还有一些问题要解决，那就是前面定义中提到的第二点：要在不违背封装原则的前提下，进行对象的备份和恢复。而上面的代码并不满足这一点，主要体现在下面两方面：

第一，为了能用快照恢复 InputText 对象，我们在 InputText 类中定义了 setText() 函数，但这个函数有可能会被其他业务使用，所以，暴露不应该暴露的函数违背了封装原则；

第二，快照本身是不可变的，理论上讲，不应该包含任何 set() 等修改内部状态的函数，但在上面的代码实现中，“快照“这个业务模型复用了 InputText 类的定义，而 InputText 类本身有一系列修改内部状态的函数，所以，用 InputText 类来表示快照违背了封装原则。

针对以上问题，我们对代码做两点修改。其一，定义一个独立的类（Snapshot 类）来表示快照，而不是复用 InputText 类。这个类只暴露 get() 方法，没有 set() 等任何修改内部状态的方法。其二，在 InputText 类中，我们把 setText() 方法重命名为 restoreSnapshot() 方法，用意更加明确，只用来恢复对象。

按照这个思路，我们对代码进行重构。重构之后的代码如下所示：

public class InputText {

  private StringBuilder text = new StringBuilder();

  public String getText() {

​    return text.toString();

  }

  public void append(String input) {

​    text.append(input);

  }

  public Snapshot createSnapshot() {

​    return new Snapshot(text.toString());

  }

  public void restoreSnapshot(Snapshot snapshot) {

​    this.text.replace(0, this.text.length(), snapshot.getText());

  }

}

public class Snapshot {

  private String text;

  public Snapshot(String text) {

​    this.text = text;

  }

  public String getText() {

​    return this.text;

  }

}

public class SnapshotHolder {

  private Stack<Snapshot> snapshots = new Stack<>();

  public Snapshot popSnapshot() {

​    return snapshots.pop();

  }

  public void pushSnapshot(Snapshot snapshot) {

​    snapshots.push(snapshot);

  }

}

public class ApplicationMain {

  public static void main(String[] args) {

​    InputText inputText = new InputText();

​    SnapshotHolder snapshotsHolder = new SnapshotHolder();

​    Scanner scanner = new Scanner(System.in);

​    while (scanner.hasNext()) {

​      String input = scanner.next();

​      if (input.equals(":list")) {

​        System.out.println(inputText.toString());

​      } else if (input.equals(":undo")) {

​        Snapshot snapshot = snapshotsHolder.popSnapshot();

​        inputText.restoreSnapshot(snapshot);

​      } else {

​        snapshotsHolder.pushSnapshot(inputText.createSnapshot());

​        inputText.append(input);

​      }

​    }

  }

}

实际上，上面的代码实现就是典型的备忘录模式的代码实现，也是很多书籍（包括 GoF 的《设计模式》）中给出的实现方法。

除了备忘录模式，还有一个跟它很类似的概念，“备份”，它在我们平时的开发中更常听到。那备忘录模式跟“备份”有什么区别和联系呢？实际上，这两者的应用场景很类似，都应用在防丢失、恢复、撤销等场景中。它们的区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。这个不难理解，这里我就不多说了。

## 如何优化内存和时间消耗？

前面我们只是简单介绍了备忘录模式的原理和经典实现，现在我们再继续深挖一下。如果要备份的对象数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗时会比较长。这个问题该如何解决呢？

不同的应用场景下有不同的解决方法。比如，我们前面举的那个例子，应用场景是利用备忘录来实现撤销操作，而且仅仅支持顺序撤销，也就是说，每次操作只能撤销上一次的输入，不能跳过上次输入撤销之前的输入。在具有这样特点的应用场景下，为了节省内存，我们不需要在快照中存储完整的文本，只需要记录少许信息，比如在获取快照当下的文本长度，用这个值结合 InputText 类对象存储的文本来做撤销操作。

我们再举一个例子。假设每当有数据改动，我们都需要生成一个备份，以备之后恢复。如果需要备份的数据很大，这样高频率的备份，不管是对存储（内存或者硬盘）的消耗，还是对时间的消耗，都可能是无法接受的。想要解决这个问题，我们一般会采用“低频率全量备份”和“高频率增量备份”相结合的方法。

全量备份就不用讲了，它跟我们上面的例子类似，就是把所有的数据“拍个快照”保存下来。所谓“增量备份”，指的是记录每次操作或数据变动。

当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能减少全量备份的数量和频率，减少对时间、内存的消耗。

## 重点回顾

好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。

备忘录模式也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。

备忘录模式的应用场景也比较明确和有限，主要是用来防丢失、撤销、恢复等。它跟平时我们常说的“备份”很相似。两者的主要区别在于，备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计。

对于大对象的备份来说，备份占用的存储空间会比较大，备份和恢复的耗时会比较长。针对这个问题，不同的业务场景有不同的处理方式。比如，只备份必要的恢复信息，结合最新的数据来恢复；再比如，全量备份和增量备份相结合，低频全量备份，高频增量备份，两者结合来做恢复。

## 课堂讨论

今天我们讲到，备份在架构或产品设计中比较常见，比如，重启 Chrome 可以选择恢复之前打开的页面，你还能想到其他类似的应用场景吗？

# 71 | 命令模式：如何利用命令模式实现一个手游后端架构？

王争 2020-04-15

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：8.51M 时长：09:17

设计模式模块已经接近尾声了，现在我们只剩下 3 个模式还没有学习，它们分别是：命令模式、解释器模式、中介模式。这 3 个模式使用频率低、理解难度大，只在非常特定的应用场景下才会用到，所以，不是我们学习的重点，你只需要稍微了解，见了能认识就可以了。

今天呢，我们来学习其中的命令模式。在学习这个模式的过程中，你可能会遇到的最大的疑惑是，感觉命令模式没啥用，是一种过度设计，有更加简单的设计思路可以替代。所以，我今天讲解的重点是这个模式的设计意图，带你搞清楚到底什么情况下才真正需要使用它。

话不多说，让我们正式开始今天的学习吧！

## 命令模式的原理解读

命令模式的英文翻译是 Command Design Pattern。在 GoF 的《设计模式》一书中，它是这么定义的：

The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.

翻译成中文就是下面这样。为了帮助你理解，我对这个翻译稍微做了补充和解释，也一起放在了下面的括号中。

命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。

对于 GoF 给出的定义，我这里再进一步解读一下。

落实到编码实现，命令模式用的最核心的实现手段，是将函数封装成对象。我们知道，C 语言支持函数指针，我们可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，我们可以将函数封装成对象。具体来说就是，设计一个包含这个函数的类，实例化一个对象传来传去，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的回调。

当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。

## 命令模式的实战讲解

上面的讲解比较偏理论，比较不好理解，我这里再结合一个具体的例子来解释一下。

假设我们正在开发一个类似《天天酷跑》或者《QQ 卡丁车》这样的手游。这种游戏本身的复杂度集中在客户端。后端基本上只负责数据（比如积分、生命值、装备）的更新和查询，所以，后端逻辑相对于客户端来说，要简单很多。

考虑到你可能对游戏开发不熟悉，我这里稍微交代一些背景知识。

为了提高性能，我们会把游戏中玩家的信息保存在内存中。在游戏进行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档，也就是持久化到数据库中。为了降低实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务上。这样，一个玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器去查找了，实现起来就简单了很多。

一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，为了节省网络连接建立的开销，客户端和服务器之间一般采用长连接的方式来通信。通信的格式有多种，比如 Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，指令我们也可以叫作事件，数据是执行这个指令所需的数据。

服务器在接收到客户端的请求之后，会解析出指令和数据，并且根据指令的不同，执行不同的处理逻辑。对于这样的一个业务场景，一般有两种架构实现思路。

常用的一种实现思路是利用多线程。一个线程接收请求，接收到请求之后，启动一个新的线程来处理请求。具体点讲，一般是通过一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个专门用来处理请求的线程池中，捞出一个空闲线程来处理。

另一种实现思路是在一个线程内轮询接收请求和处理请求。这种处理方式不太常见。尽管它无法利用多线程多核处理的优势，但是对于 IO 密集型的业务来说，它避免了多线程不停切换对性能的损耗，并且克服了多线程编程 Bug 比较难调试的缺点，也算是手游后端服务器开发中比较常见的架构模式了。

我们接下来就重点讲一下第二种实现方式。

整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。具体的示例代码如下所示，你可以结合着一块看下。

public interface Command {

  void execute();

}

public class GotDiamondCommand implements Command {

  // 省略成员变量

  public GotDiamondCommand(/*数据*/) {

​    //...

  }

  @Override

  public void execute() {

​    // 执行相应的逻辑

  }

}

//GotStartCommand/HitObstacleCommand/ArchiveCommand类省略

public class GameApplication {

  private static final int MAX_HANDLED_REQ_COUNT_PER_LOOP = 100;

  private Queue<Command> queue = new LinkedList<>();

  public void mainloop() {

​    while (true) {

​      List<Request> requests = new ArrayList<>();

​      

​      //省略从epoll或者select中获取数据，并封装成Request的逻辑，

​      //注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理。

​      

​      for (Request request : requests) {

​        Event event = request.getEvent();

​        Command command = null;

​        if (event.equals(Event.GOT_DIAMOND)) {

​          command = new GotDiamondCommand(/*数据*/);

​        } else if (event.equals(Event.GOT_STAR)) {

​          command = new GotStartCommand(/*数据*/);

​        } else if (event.equals(Event.HIT_OBSTACLE)) {

​          command = new HitObstacleCommand(/*数据*/);

​        } else if (event.equals(Event.ARCHIVE)) {

​          command = new ArchiveCommand(/*数据*/);

​        } // ...一堆else if...

​        queue.add(command);

​      }

​      int handledCount = 0;

​      while (handledCount < MAX_HANDLED_REQ_COUNT_PER_LOOP) {

​        if (queue.isEmpty()) {

​          break;

​        }

​        Command command = queue.poll();

​        command.execute();

​      }

​    }

  }

}

## 命令模式 VS 策略模式

看了刚才的讲解，你可能会觉得，命令模式跟策略模式、工厂模式非常相似啊，那它们的区别在哪里呢？不仅如此，在留言区中我还看到有不止一个同学反映，感觉学过的很多模式都很相似。不知道你有没有类似的感觉呢？

实际上，这个问题我之前简单提到过，可能没有作为重点来说，有些同学印象不是很深刻，这里我就再跟你讲一讲。

实际上，每个设计模式都应该由两部分组成：第一部分是应用场景，即这个模式可以解决哪类问题；第二部分是解决方案，即这个模式的设计思路和具体的代码实现。不过，代码实现并不是模式必须包含的。如果你单纯地只关注解决方案这一部分，甚至只关注代码实现，就会产生大部分模式看起来都很相似的错觉。

实际上，设计模式之间的主要区别还是在于设计意图，也就是应用场景。单纯地看设计思路或者代码实现，有些模式确实很相似，比如策略模式和工厂模式。

之前讲策略模式的时候，我们有讲到，策略模式包含策略的定义、创建和使用三部分，从代码结构上来，它非常像工厂模式。它们的区别在于，策略模式侧重“策略”或“算法”这个特定的应用场景，用来解决根据运行时状态从一组策略中选择不同策略的问题，而工厂模式侧重封装对象的创建过程，这里的对象没有任何业务场景的限定，可以是策略，但也可以是其他东西。从设计意图上来，这两个模式完全是两回事儿。

有了刚刚的铺垫，接下来，我们再来看命令模式跟策略模式的区别。你可能会觉得，命令的执行逻辑也可以看作策略，那它是不是就是策略模式了呢？实际上，这两者有一点细微的区别。

在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换。

## 重点回顾

好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。

命令模式在平时工作中并不常用，你稍微了解一下就可以。今天，我重点讲解了它的设计意图，也就是能解决什么问题。

落实到编码实现，命令模式用到最核心的实现手段，就是将函数封装成对象。我们知道，在大部分编程语言中，函数是没法作为参数传递给其他函数的，也没法赋值给变量。借助命令模式，我们将函数封装成对象，这样就可以实现把函数像对象一样使用。

命令模式的主要作用和应用场景，是用来控制命令的执行，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等，这才是命令模式能发挥独一无二作用的地方。

## 课堂讨论

从我们已经学过的这些设计模式中，找两个代码实现或者设计思路很相似的模式，说一说它们的不同点。

# 72 | 解释器模式：如何设计实现一个自定义接口告警规则功能？

王争 2020-04-17

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：9.17M 时长：10:00

上一节课，我们学习了命令模式。命令模式将请求封装成对象，方便作为函数参数传递和赋值给变量。它主要的应用场景是给命令的执行附加功能，换句话说，就是控制命令的执行，比如，排队、异步、延迟执行命令、给命令执行记录日志、撤销重做命令等等。总体上来讲，命令模式的应用范围并不广。

今天，我们来学习解释器模式，它用来描述如何构建一个简单的“语言”解释器。比起命令模式，解释器模式更加小众，只在一些特定的领域会被用到，比如编译器、规则引擎、正则表达式。所以，解释器模式也不是我们学习的重点，你稍微了解一下就可以了。

话不多说，让我们正式开始今天的学习吧！

## 解释器模式的原理和实现

解释器模式的英文翻译是 Interpreter Design Pattern。在 GoF 的《设计模式》一书中，它是这样定义的：

Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.

翻译成中文就是：解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。

看了定义，你估计会一头雾水，因为这里面有很多我们平时开发中很少接触的概念，比如“语言”“语法”“解释器”。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。

要想了解“语言”表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。

为了让你更好地理解定义，我举一个比较贴近生活的例子来解释一下。

实际上，理解这个概念，我们可以类比中英文翻译。我们知道，把英文翻译成中文是有一定规则的。这个规则就是定义中的“语法”。我们开发一个类似 Google Translate 这样的翻译器，这个翻译器能够根据语法规则，将输入的中文翻译成英文。这里的翻译器就是解释器模式定义中的“解释器”。

刚刚翻译器这个例子比较贴近生活，现在，我们再举个更加贴近编程的例子。

假设我们定义了一个新的加减乘除计算“语言”，语法规则如下：

运算符只包含加、减、乘、除，并且没有优先级的概念；

表达式（也就是前面提到的“句子”）中，先书写数字，后书写运算符，空格隔开；

按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式最终的计算结果。

我们举个例子来解释一下上面的语法规则。

比如“ 8 3 2 4 - + * ”这样一个表达式，我们按照上面的语法规则来处理，取出数字“8 3”和“-”运算符，计算得到 5，于是表达式就变成了“ 5 2 4 + * ”。然后，我们再取出“ 5 2 ”和“ + ”运算符，计算得到 7，表达式就变成了“ 7 4 * ”。最后，我们取出“ 7 4”和“ * ”运算符，最终得到的结果就是 28。

看懂了上面的语法规则，我们将它用代码实现出来，如下所示。代码非常简单，用户按照上面的规则书写表达式，传递给 interpret() 函数，就可以得到最终的计算结果。

public class ExpressionInterpreter {

  private Deque<Long> numbers = new LinkedList<>();

  public long interpret(String expression) {

​    String[] elements = expression.split(" ");

​    int length = elements.length;

​    for (int i = 0; i < (length+1)/2; ++i) {

​      numbers.addLast(Long.parseLong(elements[i]));

​    }

​    for (int i = (length+1)/2; i < length; ++i) {

​      String operator = elements[i];

​      boolean isValid = "+".equals(operator) || "-".equals(operator)

​              || "*".equals(operator) || "/".equals(operator);

​      if (!isValid) {

​        throw new RuntimeException("Expression is invalid: " + expression);

​      }

​      long number1 = numbers.pollFirst();

​      long number2 = numbers.pollFirst();

​      long result = 0;

​      if (operator.equals("+")) {

​        result = number1 + number2;

​      } else if (operator.equals("-")) {

​        result = number1 - number2;

​      } else if (operator.equals("*")) {

​        result = number1 * number2;

​      } else if (operator.equals("/")) {

​        result = number1 / number2;

​      }

​      numbers.addFirst(result);

​    }

​    if (numbers.size() != 1) {

​      throw new RuntimeException("Expression is invalid: " + expression);

​    }

​    return numbers.pop();

  }

}

在上面的代码实现中，语法规则的解析逻辑（第 23、25、27、29 行）都集中在一个函数中，对于简单的语法规则的解析，这样的设计就足够了。但是，对于复杂的语法规则的解析，逻辑复杂，代码量多，所有的解析逻辑都耦合在一个函数中，这样显然是不合适的。这个时候，我们就要考虑拆分代码，将解析逻辑拆分到独立的小类中。

该怎么拆分呢？我们可以借助解释器模式。

解释器模式的代码实现比较灵活，没有固定的模板。我们前面也说过，应用设计模式主要是应对代码的复杂性，实际上，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。

前面定义的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除。利用解释器模式，我们把解析的工作拆分到 NumberExpression、AdditionExpression、SubstractionExpression、MultiplicationExpression、DivisionExpression 这样五个解析类中。

按照这个思路，我们对代码进行重构，重构之后的代码如下所示。当然，因为加减乘除表达式的解析比较简单，利用解释器模式的设计思路，看起来有点过度设计。不过呢，这里我主要是为了解释原理，你明白意思就好，不用过度细究这个例子。

public interface Expression {

  long interpret();

}

public class NumberExpression implements Expression {

  private long number;

  public NumberExpression(long number) {

​    this.number = number;

  }

  public NumberExpression(String number) {

​    this.number = Long.parseLong(number);

  }

  @Override

  public long interpret() {

​    return this.number;

  }

}

public class AdditionExpression implements Expression {

  private Expression exp1;

  private Expression exp2;

  public AdditionExpression(Expression exp1, Expression exp2) {

​    this.exp1 = exp1;

​    this.exp2 = exp2;

  }

  @Override

  public long interpret() {

​    return exp1.interpret() + exp2.interpret();

  }

}

// SubstractionExpression/MultiplicationExpression/DivisionExpression与AdditionExpression代码结构类似，这里就省略了

public class ExpressionInterpreter {

  private Deque<Expression> numbers = new LinkedList<>();

  public long interpret(String expression) {

​    String[] elements = expression.split(" ");

​    int length = elements.length;

​    for (int i = 0; i < (length+1)/2; ++i) {

​      numbers.addLast(new NumberExpression(elements[i]));

​    }

​    for (int i = (length+1)/2; i < length; ++i) {

​      String operator = elements[i];

​      boolean isValid = "+".equals(operator) || "-".equals(operator)

​              || "*".equals(operator) || "/".equals(operator);

​      if (!isValid) {

​        throw new RuntimeException("Expression is invalid: " + expression);

​      }

​      Expression exp1 = numbers.pollFirst();

​      Expression exp2 = numbers.pollFirst();

​      Expression combinedExp = null;

​      if (operator.equals("+")) {

​        combinedExp = new AdditionExpression(exp1, exp2);

​      } else if (operator.equals("-")) {

​        combinedExp = new AdditionExpression(exp1, exp2);

​      } else if (operator.equals("*")) {

​        combinedExp = new AdditionExpression(exp1, exp2);

​      } else if (operator.equals("/")) {

​        combinedExp = new AdditionExpression(exp1, exp2);

​      }

​      long result = combinedExp.interpret();

​      numbers.addFirst(new NumberExpression(result));

​    }

​    if (numbers.size() != 1) {

​      throw new RuntimeException("Expression is invalid: " + expression);

​    }

​    return numbers.pop().interpret();

  }

}

## 解释器模式实战举例

接下来，我们再来看一个更加接近实战的例子，也就是咱们今天标题中的问题：如何实现一个自定义接口告警规则功能？

在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。比如，如果每分钟接口出错数超过 100，监控系统就通过短信、微信、邮件等方式发送告警给开发者。

一般来讲，监控系统支持开发者自定义告警规则，比如我们可以用下面这样一个表达式，来表示一个告警规则，它表达的意思是：每分钟 API 总出错数超过 100 或者每分钟 API 总调用数超过 10000 就触发告警。

api_error_per_minute > 100 || api_count_per_minute > 10000

在监控系统中，告警模块只负责根据统计数据和告警规则，判断是否触发告警。至于每分钟 API 接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个 Map 中（数据的格式如下所示），发送给告警模块。接下来，我们只关注告警模块。

Map<String, Long> apiStat = new HashMap<>();

apiStat.put("api_error_per_minute", 103);

apiStat.put("api_count_per_minute", 987);

为了简化讲解和代码实现，我们假设自定义的告警规则只包含“||、&&、>、<、==”这五个运算符，其中，“>、<、==”运算符的优先级高于“||、&&”运算符，“&&”运算符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的 key，比如前面的 api_error_per_minute、api_count_per_minute。

那如何实现上面的需求呢？我写了一个骨架代码，如下所示，其中的核心的实现我没有给出，你可以当作面试题，自己试着去补全一下，然后再看我的讲解。

public class AlertRuleInterpreter {

  // key1 > 100 && key2 < 1000 || key3 == 200

  public AlertRuleInterpreter(String ruleExpression) {

​    //TODO:由你来完善

  }

  //<String, Long> apiStat = new HashMap<>();

  //apiStat.put("key1", 103);

  //apiStat.put("key2", 987);

  public boolean interpret(Map<String, Long> stats) {

​    //TODO:由你来完善

  }

}

public class DemoTest {

  public static void main(String[] args) {

​    String rule = "key1 > 100 && key2 < 30 || key3 < 100 || key4 == 88";

​    AlertRuleInterpreter interpreter = new AlertRuleInterpreter(rule);

​    Map<String, Long> stats = new HashMap<>();

​    stats.put("key1", 101l);

​    stats.put("key3", 121l);

​    stats.put("key4", 88l);

​    boolean alert = interpreter.interpret(stats);

​    System.out.println(alert);

  }

}

实际上，我们可以把自定义的告警规则，看作一种特殊“语言”的语法规则。我们实现一个解释器，能够根据规则，针对用户输入的数据，判断是否触发告警。利用解释器模式，我们把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。按照这个实现思路，我把刚刚的代码补全，如下所示，你可以拿你写的代码跟我写的对比一下。

public interface Expression {

  boolean interpret(Map<String, Long> stats);

}

public class GreaterExpression implements Expression {

  private String key;

  private long value;

  public GreaterExpression(String strExpression) {

​    String[] elements = strExpression.trim().split("\\s+");

​    if (elements.length != 3 || !elements[1].trim().equals(">")) {

​      throw new RuntimeException("Expression is invalid: " + strExpression);

​    }

​    this.key = elements[0].trim();

​    this.value = Long.parseLong(elements[2].trim());

  }

  public GreaterExpression(String key, long value) {

​    this.key = key;

​    this.value = value;

  }

  @Override

  public boolean interpret(Map<String, Long> stats) {

​    if (!stats.containsKey(key)) {

​      return false;

​    }

​    long statValue = stats.get(key);

​    return statValue > value;

  }

}

// LessExpression/EqualExpression跟GreaterExpression代码类似，这里就省略了

public class AndExpression implements Expression {

  private List<Expression> expressions = new ArrayList<>();

  public AndExpression(String strAndExpression) {

​    String[] strExpressions = strAndExpression.split("&&");

​    for (String strExpr : strExpressions) {

​      if (strExpr.contains(">")) {

​        expressions.add(new GreaterExpression(strExpr));

​      } else if (strExpr.contains("<")) {

​        expressions.add(new LessExpression(strExpr));

​      } else if (strExpr.contains("==")) {

​        expressions.add(new EqualExpression(strExpr));

​      } else {

​        throw new RuntimeException("Expression is invalid: " + strAndExpression);

​      }

​    }

  }

  public AndExpression(List<Expression> expressions) {

​    this.expressions.addAll(expressions);

  }

  @Override

  public boolean interpret(Map<String, Long> stats) {

​    for (Expression expr : expressions) {

​      if (!expr.interpret(stats)) {

​        return false;

​      }

​    }

​    return true;

  }

}

public class OrExpression implements Expression {

  private List<Expression> expressions = new ArrayList<>();

  public OrExpression(String strOrExpression) {

​    String[] andExpressions = strOrExpression.split("\\|\\|");

​    for (String andExpr : andExpressions) {

​      expressions.add(new AndExpression(andExpr));

​    }

  }

  public OrExpression(List<Expression> expressions) {

​    this.expressions.addAll(expressions);

  }

  @Override

  public boolean interpret(Map<String, Long> stats) {

​    for (Expression expr : expressions) {

​      if (expr.interpret(stats)) {

​        return true;

​      }

​    }

​    return false;

  }

}

public class AlertRuleInterpreter {

  private Expression expression;

  public AlertRuleInterpreter(String ruleExpression) {

​    this.expression = new OrExpression(ruleExpression);

  }

  public boolean interpret(Map<String, Long> stats) {

​    return expression.interpret(stats);

  }

} 

## 重点回顾

好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。

解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。实际上，这里的“语言”不仅仅指我们平时说的中、英、日、法等各种语言。从广义上来讲，只要是能承载信息的载体，我们都可以称之为“语言”，比如，古代的结绳记事、盲文、哑语、摩斯密码等。

要想了解“语言”要表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“句子”（专业点的叫法应该是“表达式”），阅读者根据语法规则来阅读“句子”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“句子”的解释器。

解释器模式的代码实现比较灵活，没有固定的模板。我们前面说过，应用设计模式主要是应对代码的复杂性，解释器模式也不例外。它的代码实现的核心思想，就是将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类。一般的做法是，将语法规则拆分一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。

## 课堂讨论

\1. 在你过往的项目经历或阅读源码的时候，有没有用到或者见过解释器模式呢？

\2. 在告警规则解析的例子中，如果我们要在表达式中支持括号“（）”，那如何对代码进行重构呢？你可以把它当作练习，试着编写一下代码。

# 73 | 中介模式：什么时候用中介模式？什么时候用观察者模式？

王争 2020-04-20

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：7.08M 时长：07:43

今天，我们来学习 23 种经典设计模式中的最后一个，中介模式。跟前面刚刚讲过的命令模式、解释器模式类似，中介模式也属于不怎么常用的模式，应用场景比较特殊、有限，但是，跟它俩不同的是，中介模式理解起来并不难，代码实现也非常简单，学习难度要小很多。

如果你对中介模式有所了解，你可能会知道，中介模式跟之前讲过的观察者模式有点相似，所以，今天我们还会详细讨论下这两种模式的区别。

话不多说，让我们正式开始今天的学习吧！

## 中介模式的原理和实现

中介模式的英文翻译是 Mediator Design Pattern。在 GoF 中的《设计模式》一书中，它是这样定义的：

Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.

翻译成中文就是：中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。

还记得我们在[第 30 节课](undefined)中讲的“如何给代码解耦”吗？其中一个方法就是引入中间层。

实际上，中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。

这里我画了一张对象交互关系的对比图。其中，右边的交互图是利用中介模式对左边交互关系优化之后的结果，从图中我们可以很直观地看出，右边的交互关系更加清晰、简洁。

![](https://static001.geekbang.org/resource/image/43/9f/4376d541bf17a029f37aa76009ef3a9f.jpg)

提到中介模式，有一个比较经典的例子不得不说，那就是航空管制。

为了让飞机在飞行的时候互不干扰，每架飞机都需要知道其他飞机每时每刻的位置，这就需要时刻跟其他飞机通信。飞机通信形成的通信网络就会无比复杂。这个时候，我们通过引入“塔台”这样一个中介，让每架飞机只跟塔台来通信，发送自己的位置给塔台，由塔台来负责每架飞机的航线调度。这样就大大简化了通信网络。

刚刚举的是生活中的例子，我们再举一个跟编程开发相关的例子。这个例子与 UI 控件有关，算是中介模式比较经典的应用，很多书籍在讲到中介模式的时候，都会拿它来举例。

假设我们有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。当我们对某个控件进行操作的时候，其他控件会做出相应的反应，比如，我们在下拉框中选择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登陆相关的控件就会显示在对话框中。

按照通常我们习惯的 UI 界面的开发方式，我们将刚刚的需求用代码实现出来，就是下面这个样子。在这种实现方式中，控件和控件之间互相操作、互相依赖。

public class UIControl {

  private static final String LOGIN_BTN_ID = "login_btn";

  private static final String REG_BTN_ID = "reg_btn";

  private static final String USERNAME_INPUT_ID = "username_input";

  private static final String PASSWORD_INPUT_ID = "pswd_input";

  private static final String REPEATED_PASSWORD_INPUT_ID = "repeated_pswd_input";

  private static final String HINT_TEXT_ID = "hint_text";

  private static final String SELECTION_ID = "selection";

  public static void main(String[] args) {

​    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);

​    Button regButton = (Button)findViewById(REG_BTN_ID);

​    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);

​    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);

​    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);

​    Text hintText = (Text)findViewById(HINT_TEXT_ID);

​    Selection selection = (Selection)findViewById(SELECTION_ID);

​    loginButton.setOnClickListener(new OnClickListener() {

​      @Override

​      public void onClick(View v) {

​        String username = usernameInput.text();

​        String password = passwordInput.text();

​        //校验数据...

​        //做业务处理...

​      }

​    });

​    regButton.setOnClickListener(new OnClickListener() {

​      @Override

​      public void onClick(View v) {

​      //获取usernameInput、passwordInput、repeatedPswdInput数据...

​      //校验数据...

​      //做业务处理...

​      }

​    });

​    //...省略selection下拉选择框相关代码....

  }

}

我们再按照中介模式，将上面的代码重新实现一下。在新的代码实现中，各个控件只跟中介对象交互，中介对象负责所有业务逻辑的处理。

public interface Mediator {

  void handleEvent(Component component, String event);

}

public class LandingPageDialog implements Mediator {

  private Button loginButton;

  private Button regButton;

  private Selection selection;

  private Input usernameInput;

  private Input passwordInput;

  private Input repeatedPswdInput;

  private Text hintText;

  @Override

  public void handleEvent(Component component, String event) {

​    if (component.equals(loginButton)) {

​      String username = usernameInput.text();

​      String password = passwordInput.text();

​      //校验数据...

​      //做业务处理...

​    } else if (component.equals(regButton)) {

​      //获取usernameInput、passwordInput、repeatedPswdInput数据...

​      //校验数据...

​      //做业务处理...

​    } else if (component.equals(selection)) {

​      String selectedItem = selection.select();

​      if (selectedItem.equals("login")) {

​        usernameInput.show();

​        passwordInput.show();

​        repeatedPswdInput.hide();

​        hintText.hide();

​        //...省略其他代码

​      } else if (selectedItem.equals("register")) {

​        //....

​      }

​    }

  }

}

public class UIControl {

  private static final String LOGIN_BTN_ID = "login_btn";

  private static final String REG_BTN_ID = "reg_btn";

  private static final String USERNAME_INPUT_ID = "username_input";

  private static final String PASSWORD_INPUT_ID = "pswd_input";

  private static final String REPEATED_PASSWORD_INPUT_ID = "repeated_pswd_input";

  private static final String HINT_TEXT_ID = "hint_text";

  private static final String SELECTION_ID = "selection";

  public static void main(String[] args) {

​    Button loginButton = (Button)findViewById(LOGIN_BTN_ID);

​    Button regButton = (Button)findViewById(REG_BTN_ID);

​    Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);

​    Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);

​    Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);

​    Text hintText = (Text)findViewById(HINT_TEXT_ID);

​    Selection selection = (Selection)findViewById(SELECTION_ID);

​    Mediator dialog = new LandingPageDialog();

​    dialog.setLoginButton(loginButton);

​    dialog.setRegButton(regButton);

​    dialog.setUsernameInput(usernameInput);

​    dialog.setPasswordInput(passwordInput);

​    dialog.setRepeatedPswdInput(repeatedPswdInput);

​    dialog.setHintText(hintText);

​    dialog.setSelection(selection);

​    loginButton.setOnClickListener(new OnClickListener() {

​      @Override

​      public void onClick(View v) {

​        dialog.handleEvent(loginButton, "click");

​      }

​    });

​    regButton.setOnClickListener(new OnClickListener() {

​      @Override

​      public void onClick(View v) {

​        dialog.handleEvent(regButton, "click");

​      }

​    });

​    //....

  }

}

从代码中我们可以看出，原本业务逻辑会分散在各个控件中，现在都集中到了中介类中。实际上，这样做既有好处，也有坏处。好处是简化了控件之间的交互，坏处是中介类有可能会变成大而复杂的“上帝类”（God Class）。所以，在使用中介模式的时候，我们要根据实际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。

## 中介模式 VS 观察者模式

前面讲观察者模式的时候，我们讲到，观察者模式有多种实现方式。虽然经典的实现方式没法彻底解耦观察者和被观察者，观察者需要注册到被观察者中，被观察者状态更新需要调用观察者的 update() 方法。但是，在跨进程的实现方式中，我们可以利用消息队列实现彻底解耦，观察者和被观察者都只需要跟消息队列交互，观察者完全不知道被观察者的存在，被观察者也完全不知道观察者的存在。

我们前面提到，中介模式也是为了解耦对象之间的交互，所有的参与者都只与中介进行交互。而观察者模式中的消息队列，就有点类似中介模式中的“中介”，观察者模式的中观察者和被观察者，就有点类似中介模式中的“参与者”。那问题来了：中介模式和观察者模式的区别在哪里呢？什么时候选择使用中介模式？什么时候选择使用观察者模式呢？

在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。

而中介模式正好相反。只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式。毕竟，中介模式的应用会带来一定的副作用，前面也讲到，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而观察者模式是无法实现这样的顺序要求的。

## 重点回顾

好了，今天的内容到此就讲完了。我们一块来总结回顾一下，你需要重点掌握的内容。

中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。

观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的应用场景中，参与者之间的交互关系错综复杂，既可以是消息的发送者、也可以同时是消息的接收者。

## 课堂讨论

在讲观察者模式的时候，我们有讲到 EventBus 框架。当时我们认为它是观察者模式的实现框架。EventBus 作为一个事件处理的中心，事件的派送、订阅都通过这个中心来完成，那是不是更像中介模式的实现框架呢？

