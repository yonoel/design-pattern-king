# 开篇词 | 一对一的设计与编码集训，让你告别没有成长的烂代码！

王争 2019-11-04

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：12.10M 时长：13:12

你好，我是王争，是“[数据结构与算法之美](undefined)”专栏的作者。“数据结构与算法之美”专栏在今年 2 月底全部更新完毕。时隔 8 个月，我又给你带来了一个新的专栏“设计模式之美”。如果说“数据结构与算法之美”是教你写出高效的代码，那这个设计模式专栏就是教你写出高质量的代码。

## 程序员的看家本领你得练好

研究生毕业后我就加入了 Google，至今我还清晰地记得，我第一次提交代码的时候，短短的 100 多行代码，被同事 review 出了 n 多问题，来来回回改了不下十几个版本才提交上去。我当时有很大的逆反心理，觉得有必要浪费这么多时间在如此细节的编码上吗？只要代码能用、能解决问题不就够了吗？

工作一段时间之后，我才发现自己当时的想法有多幼稚。

写代码可以说是程序员天天要干的事情，要是代码都写不好，最基本的看家本领都练不好，成天堆砌烂代码，写代码还有啥意思呢？那还干啥程序员啊！写出“能用”代码的人比比皆是，但是，并不是每个人都能写出“好用”的代码。只会写能用的代码，我们永远成长不成大牛，成长不成最优秀的那批人。

后来我熟练掌握了各种编写高质量代码的技巧、方法和理论，我发现，实际上，写烂代码和好代码花费的时间是差不多的。当你把写高质量代码培养成一种开发习惯之后，在你在编写代码的时候，自然就有一种代码质量意识，自然而然就可以写出不错的代码。即便在我离开 Google 加入其他公司之后，项目的代码质量因为各种原因有所妥协，但我起码知道什么样的代码是高质量代码，丝毫不影响我具备写出高质量代码的能力。

我相信，很多工程师都很重视代码质量，毕竟谁也不想写被人吐槽的烂代码。但是，就我的了解来看，毫不夸张地讲，很多工程师，甚至一些 BAT 的员工，代码都写得惨不忍睹。一方面，在目前这种快糙猛的开发环境下，很多工程师并没有太多时间去思考如何写高质量代码；另一方面，在烂代码的熏陶下，在没有人指导的环境里，很多工程师也搞不大清楚高质量代码到底长什么样。

这就导致很多工程师写了多年代码，代码功力一点都没长进，编写的代码仍然只是能用即可，能运行就好。平日的工作就是修修补补、抄抄改改，一直在做重复劳动，能力也一直停留在“会干活”的层面，就像高速路上的收银员，只能算是一个“熟练工”。

## 一个人闷头看书效果并不好

当然，也有一些比较上进的工程师，会去找设计模式、编码规范、重构等类型的书籍去看，学习如何编写高质量的代码。实际上，我也买了很多这类的书籍来看，从这些经典的书籍中，我也学到了很多编程技巧和提高代码质量的方法。

不过，这些书籍都有一个特点，那就是比较偏重理论讲解，喜欢拿猫、狗之类生活中的例子来举例。当然，这样的例子也有优点，那就是能在简短的时间和篇幅内，很好地帮你理解原理。但同时也存在一个严重的问题，那就是过于脱离真实的软件开发。而且例子本身没有难度，你一看就觉得懂了，但是看完之后，可能还是不清楚如何将理论落地到实际的项目编码中。

比如，我们都知道著名的 KISS 原则（Keep It Simple and Stupid）。这个原则理解起来很简单，一看貌似就懂了，那我问你，怎样的代码才算是足够简单呢？怎样才算不够简单需要优化呢？估计很多人都回答不上来，因为大部分书籍都没有讲清楚。

除此之外，一个人自己闷头看书，在很多时候效果并不好。一方面，每个人的理解能力是不一样的。对于同一本书，不同理解能力的人看完之后收获也是不一样的。跟着有经验的老师学比闷头自己看书要更高效、收获更多、成长更快。另一方面，编码本身就是一门实践课，光闷头看书本理论肯定是不够的，更重要的是在实践中学习如何应用这些理论。

## 一对一手把手指导才最有效

从我的经验来看，我觉得最有效、最快速提高编码能力的方法就是，找一个比你资深的工程师，一对一、手把手地指导你写代码。你提交代码，他来指出你的问题，你再优化，这样一来一往，要不了多久，你就会发现，自己的代码能力突飞猛进。

但是，理想很丰满，现实很骨感。且不说能不能找到这样有资格指导你的人，即便能找到，他愿不愿意、有没有时间来手把手指导你，还是另外一回事。而我比较幸运，在毕业之后就加入了 Google，得到了顶尖工程师的指导，一对一地给我 review 代码，手把手地指导我如何优化代码。正因如此，在 Google 的那段时间也成为了我编码能力提高最快的一段时间。

所以，在设计专栏的初期，我就在想，如果我能模拟这样一个一对一、手把手、就真实项目代码讲解的场景，是不是就能让专栏有别于千篇一律的书籍，从而能真正提高你的代码能力呢？基于这样一个想法，我们接下来就来看，我是如何设计整个专栏内容的。

## 我是如何设计这个专栏的？

### 100 多篇文章、50 万字、2 万多行代码

整个专栏的文章总共有 100 多篇，每篇平均下来在 5000 字左右，所以你总共需要学习 50 万字。为什么篇幅会这么多？这是因为，我想一次性把跟编写高质量代码相关的所有知识，都系统、全面地讲清楚，一次性给你讲透彻。你看完我这一个专栏，就能搞清楚所有跟写高质量代码相关的知识点。

除此之外，为了避免脱离代码，空洞地讲理论，专栏每篇文章平均大约有 200 多行代码，整个专栏累计有 2 万多行代码。而且，这些代码都来自我这十几年积累的真实项目，而非编造出来的阿猫阿狗、停车场、餐厅之类的没有太多实际意义的代码。

我个人写 Java 代码比较多，所以，专栏中的代码我是用 Java 语言实现的。不过，在设计专栏的时候，我已经考虑到其他不熟悉 Java 语言的小伙伴了。我力争做到，实际上我觉得也已经做到，一方面，专栏内容的讲解并不与具体的编程语言挂勾；另一方面，我只用最基本、最简单的 Java 语法，只要你有一些编程基础，不管你熟悉的是哪种编程语言，都可以看懂我写的代码，理解代码背后的设计思想。

所以，如果你熟悉的不是 Java，而是 C++、C#、PHP、Python、Go、Ruby、JavaScript 等其他编程语言，不要担心，这完全不会影响你学习这个专栏。

### 200 多个真实的项目实战代码案例剖析

实际上，大部分设计原则、设计思想、设计模式理解起来都不难，难的是如何将这些理论灵活恰当地应用到实际的开发中，而不是教条主义和盲目滥用。而要想正确、得当地应用理论知识，光看书是不够的，我们要在实战中去亲身感受、体会这些理论该如何应用。但是，我们平时的开发更多的是基于已有的框架，照着别人的流程，扩展新的功能模块。所以，在工作中就可能没有那么多足够复杂、足够有难度的开发场景，让我们有机会去实践这些理论。

基于这种考虑，我结合自己过去工作中积累的项目经验，为整个专栏精心设计了 200 多个真实的项目实战代码案例。几乎每节课、每个知识点都会结合一个完整的开发案例来讲解。我们知道，刷算法最出名的就属 LeetCode 了。类比一下的话，我这 200 多个开发案例足以称得上是一个锻炼编写高质量代码的“LeetCode”了。跟着我一起把这 200 多个开发案例练下来，不愁代码能力提高不了！

### 8 个月、240 天一对一手把手编程指导

前面我有提到，提高自己编码能力，最有效的手段就是让有经验的前辈一对一、手把手地指导。我经历过 Google 最严格的 Code Review，也被最顶尖的工程师指导过，也见识过最优秀的代码长什么样子，而且自己平时也比较重视代码质量，所以，我觉得我还是有挺多写代码方面的心得体会可以分享给你的。

而且，看过“数据结构与算法之美”专栏的小伙伴都知道，我这个人最大的特点就是逻辑清晰，能抓住要点把问题讲透彻。所以，对于专栏中的理论解读，我并不会照搬那些经典的大部头书籍，而是更多地融入我自己的思考和理解。或许我的解读会跟大师的不完全一样，但我都可以自成一体，并且告诉你如何落地指导具体的开发、编码，而不是很鸡汤地浮在表面来讲，让你听的时候感觉好像都懂了，感觉思想好像得到了升华，而合上书就又忘得一干二净，更别提应用到项目中了。

当然，除了理论解读之外，对于每一种设计原则、思想或者模式，我还会讲一些更深入、更本质、更有用的东西，比如，“为什么要有这种设计原则、思想或者模式？它能解决什么编程问题？有哪些应用场景？又该如何权衡、恰当地在项目中应用？”等等。

在讲解每个实战案例的时候，我会从最原始的问题代码讲起，然后告诉你缺陷在哪里，如何通过设计原则、思想、模式来优化，让你知其然知其所以然，了解背后设计的来龙去脉。我觉得，这比单纯只告诉最终的设计结果要重要得多。我也希望，你不光是被动地听我讲，而是能跟着我的节奏主动地去思考，这对你的逻辑思维训练也会很有帮助。毕竟，对于成天跟程序逻辑打交道的程序员来说，逻辑思维能力是一项非常重要的能力。我们平时要多多加强这方面的锻炼。

除此之外，专栏内容的讲解，我也刻意模拟这种一对一指导的感觉。虽然我没法真正坐在你的面前，跟你一块讨论原理、分析如何优化代码，但我力争让你在看或者听专栏的时候，就好像我在你的面前，跟你一块讨论问题一样。 整个专栏有 100 多篇文章，一周更新 3 篇，需要持续更新 8 个多月、240 多天。这就相当于我手把手指导你 8 个月写代码。我希望通过这 8 个月的指导，能把我十几年的积累统统传授给你。

### 100 多个有深度的课堂讨论、头脑风暴

我们知道，设计问题本来就没有标准答案。 所以，不要轻信一家之言，更不要迷信我的专栏，也不要盲目追从任何一位专家、大师的说法。主动思考，积极讨论，比单纯地被动接受，学习效果要好十倍、百倍。

所以，在每节课的最后，我都设计了 1～2 道课堂讨论题，这些题目有些是代码设计相关的开放性问题，有些是具体的代码优化问题。看过我“数据结构与算法之美”专栏的小伙伴们都知道，专栏的思考题和同学们的留言，有的时候比专栏文章本身还要精彩。所以，对于这个专栏，我也希望你能积极参与，发表自己的观点。

如果你在学习完每节课程之后，都能花 5 分钟、10 分钟的时间去思考一下课堂讨论问题。这不仅对课程知识的学习很有帮助，还能锻炼你的思考能力。你要知道，独立思考能力对一个人来说是多么重要啊！

## 让我们一起见证成长

我个人觉得，“数据结构与算法之美”和“设计模式之美”是两门跟我们每天的编程开发，直接关系非常大的课程，是两门奠定一个工程师最基本的代码能力的课程。它们一个教你如何写高效代码，一个教你如何写高质量代码。弄懂了这两门课的内容，在今后的开发中，你就不需要担心写出被人吐槽的烂代码了，甚至还能让你的代码成为职场发展的一个加分项和闪光点。

前面讲到，专栏要持续更新 8 个月的时间，你可能会觉得时间好长。实际上，只要跟着专栏更新的节奏，每周认真学好 3 节课，稳扎稳打，8 个月一眨眼就过去了。而经过这 8 个月的刻意编码训练，我相信，你会发现自己因为这样的坚持学习成长了很多，不仅代码能力会提高几个档次，或许还能养成一种好的学习习惯。

最后，今天是开篇，你可以做个自我介绍，立个学习 flag。当然，你也可以留下你对专栏的期待和建议。

说起来连续 8 个月坚持学习，不是件容易事，而和志同道合的小伙伴一起，更容易找到学习的乐趣。为此，我在“极客时间小程序”发起了“8 个月，攻克设计模式”的学习打卡活动。我可以向你保证，这 8 个月只要你跟着我的节奏，踏踏实实走下来，你的代码能力一定能有一个质的飞跃。

欢迎加入，让我们一起见证成长！







# 01 | 为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？

王争 2019-11-04

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：12.21M 时长：13:19

我相信，很多程序员都已经意识到基础知识的重要性，觉得要夯实基础，才能走得更远，但同时对于如何将基础知识转化成开发“生产力”仍然有些疑惑。所以，你可能看了很多基础的书籍，比如操作系统、组成原理、编译原理等，但还是觉得很迷茫，觉得在开发中用不上，起码在平时的 CRUD 业务开发中用不上。实际上，这些基础的知识确实很难直接转化成开发“生产力”。但是，它能潜移默化地、间接地提高你对技术的理解。

不过，我觉得，设计模式和操作系统、组成原理、编译原理等这些基础学科是不一样的。它虽然也算是一门基础知识，但是它和数据结构、算法更像是一道儿的，相比那些更加基础的学科，设计模式能更直接地提高你的开发能力。我在开篇词里也说了，如果说数据结构和算法是教你如何写出高效代码，那设计模式讲的是如何写出可扩展、可读、可维护的高质量代码，所以，它们跟平时的编码会有直接的关系，也会直接影响到你的开发能力。

不过，你可能还是会觉得设计模式是把屠龙刀，看起来很厉害，但平时的开发根本用不上。基于这种观点，接下来，我们就具体地聊一聊，我们为什么要学习设计模式？

## 1. 应对面试中的设计模式相关问题

学习设计模式和算法一样，最功利、最直接的目的，可能就是应对面试了。

不管你是前端工程师、后端工程师，还是全栈工程师，在求职面试中，设计模式问题是被问得频率比较高的一类问题。特别是一些像 BAT、TMD 这样的大公司，比较重视候选人的基本功，经常会拿算法、设计模式之类的问题来考察候选人。

所以，我在求职面试的时候，都会提前准备、温习一遍设计模式。尽管并不是每次面试都会被问到，但一旦被问到，如果回答得不好，就是一个败笔，这场面试基本上也就凉凉了。所以，为了保证万无一失，摆脱一旦被问到答不出来的窘境，对于设计模式这种大概率被问到的问题，我都会未雨绸缪，提前准备一下。

当然，我并不是临时抱佛脚。我平时就比较重视设计模式相关知识的积累，所以底子比较好，只需要在每次面试前花很短的时间，重新温习一下，便可以自信满满地去面试，而不是心里老是担心被问到，影响正常的面试发挥。

所以，如果你也不想让设计模式相关问题成为你面试中的短板，那跟着我把专栏中的知识点都搞清楚，以后面试再遇到设计模式相关的问题，就不会惧怕了，甚至还会成为你面试中的亮点。

## 2. 告别写被人吐槽的烂代码

我们经常说，“Talk is cheap，show me the code。”实际上，代码能力是一个程序员最基础的能力，是基本功，是展示一个程序员基础素养的最直接的衡量标准。你写的代码，实际上就是你名片。

尽管我已经工作近十年，但我一直没有脱离编码一线，现在每天也都在坚持写代码、review 指导同事写代码、重构遗留系统的烂代码。这些年的工作经历中，我见过太多的烂代码，比如命名不规范、类设计不合理、分层不清晰、没有模块化概念、代码结构混乱、高度耦合等等。这样的代码维护起来非常费劲，添加或者修改一个功能，常常会牵一发而动全身，让你无从下手，恨不得将全部的代码删掉重写！

当然，在这些年的工作经历中，我也看到过很多让我眼前一亮的代码。每当我看到这样的好代码，都会立刻对作者产生无比的好感和认可。且不管这个人处在公司的何种级别，从代码就能看出，他是一个基础扎实的高潜员工，值得培养，前途无量！因此，代码写得好，能让你在团队中脱颖而出。

所以，我的专栏，不仅仅只是讲解设计模式，更加重要的是，我会通过实战例子，手把手教你如何避免刚刚提到的代码问题，告别被人诟病的烂代码，写出令人称道的好代码，成为团队中的代码标杆！而且，写出一份漂亮的代码，你自己也会很有成就感。

## 3. 提高复杂代码的设计和开发能力

大部分工程师比较熟悉的都是编程语言、工具、框架这些东西，因为每天的工作就是在框架里根据业务需求，填充代码。实际上，我刚工作的时候，也是做这类事情。相对来说，这样的工作并不需要你具备很强的代码设计能力，只要单纯地能理解业务，翻译成代码就可以了。

但是，有一天，我的 leader 让我开发一个跟业务无关的比较通用的功能模块，面对这样稍微复杂的代码设计和开发，我就发现我有点力不从心，不知从何下手了。因为我知道只是完成功能、代码能用，可能并不复杂，但是要想写出易扩展、易用、易维护的代码，并不容易。

如何分层、分模块？应该怎么划分类？每个类应该具有哪些属性、方法？怎么设计类之间的交互？该用继承还是组合？该使用接口还是抽象类？怎样做到解耦、高内聚低耦合？该用单例模式还是静态方法？用工厂模式创建对象还是直接 new 出来？如何避免引入设计模式提高扩展性的同时带来的降低可读性问题？……各种问题，一下子挤到了我面前。

而我当时并没有对设计模式相关的知识（包括设计模式、设计原则、面向对象设计思想等）有太多的了解和积累，所以一时间搞得我手足无措。好在因此我意识到了这方面知识的重要性，所以在之后很多年的开发中，我都一直刻意锻炼、积累这方面的能力。面对复杂代码、功能、系统的设计和开发，我也越来越得心应手，游刃有余。写出高质量代码已经成为了我的习惯，不经意间写出来的代码，都能作为同事学习、临摹的范例，这也成为了我职场中最引以为豪的亮点之一。

## 4. 让读源码、学框架事半功倍

对于一个有追求的程序员来说，对技术的积累，既要有广度，也要有深度。很多技术人早早就意识到了这一点，所以在学习框架、中间件的时候，都会抽空去研究研究原理，读一读源码，希望能在深度上有所积累，而不只是略知皮毛，会用而已。

从我的经验和同事的反馈来看，有些人看源码的时候，经常会遇到看不懂、看不下去的问题。不知道你有没有遇到过这种情况？实际上，这个问题的原因很简单，那就是你积累的基本功还不够，你的能力还不足以看懂这些代码。为什么我会这么说呢？

优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路，对于一些很明显的设计思路，你可能要花费很多时间才能参悟。相反，如果你对设计模式、原则、思想非常了解，一眼就能参透作者的设计思路、设计初衷，很快就可以把脑容量释放出来，重点思考其他问题，代码读起来就会变得轻松了。

实际上，除了看不懂、看不下去的问题，还有一个隐藏的问题，你可能自己都发现不了，那就是你自己觉得看懂了，实际上，里面的精髓你并没有 get 到多少！因为优秀的开源项目、框架、中间件，就像一个集各种高精尖技术在一起的战斗机。如果你想剖析它的原理、学习它的技术，而你没有积累深厚的基本功，就算把这台战斗机摆在你面前，你也不能完全参透它的精髓，只是了解个皮毛，看个热闹而已。

因此，学好设计模式相关的知识，不仅能让你更轻松地读懂开源项目，还能更深入地参透里面的技术精髓，做到事半功倍。

## 5. 为你的职场发展做铺垫

普通的、低级别的开发工程师，只需要把框架、开发工具、编程语言用熟练，再做几个项目练练手，基本上就能应付平时的开发工作了。但是，如果你不想一辈子做一个低级的码农，想成长为技术专家、大牛、技术 leader，希望在职场有更高的成就、更好的发展，那就要重视基本功的训练、基础知识的积累。

你去看大牛写的代码，或者优秀的开源项目，代码写得都非常的优美，质量都很高。如果你只是框架用得很溜，架构聊得头头是道，但写出来的代码很烂，让人一眼就能看出很多不合理的、可以改进的地方，那你永远都成不了别人心目中的“技术大牛”。

再者，在技术这条职场道路上，当成长到一定阶段之后，你势必要承担一些指导培养初级员工、新人，以及 code review 的工作。这个时候，如果你自己都对“什么是好的代码？如何写出好的代码？”不了解，那又该如何指导别人，如何让人家信服呢？

还有，如果你是一个技术 leader，负责一个项目整体的开发工作，你就需要为开发进度、开发效率和项目质量负责。你也不希望团队堆砌垃圾代码，让整个项目无法维护，添加、修改一个功能都要费老大劲，最终拉低整个团队的开发效率吧？

除此之外，代码质量低还会导致线上 bug 频发，排查困难。整个团队都陷在成天修改无意义的低级 bug、在烂代码中添补丁的事情中。而一个设计良好、易维护的系统，可以解放我们的时间，让我们做些更加有意义、更能提高自己和团队能力的事情。

最后，当你成为 leader、或者团队中的资深工程师、技术专家之后，你势必要负责一部分团队的招聘工作。这个时候，如果你要考察候选人的设计能力、代码能力，那设计模式相关的问题便是一个很好的考察点。

不过，我也了解到，很多面试官实际上对设计模式也并不是很了解，只能拿一些简单的单例模式、工厂模式来考察候选人，而且所出的题目往往都脱离实践，比如，如何设计一个餐厅系统、停车场系统、售票系统等。这些题目都是网上万年不变的老题目，几乎考察不出候选人的能力。在我的专栏中，有 200 多个真实项目开发中的设计模式相关问题，你跟着看下来，足以让你成为设计模式方面的大牛，再来面试候选人的时候，就不用因为题目老套、脱离实践而尴尬了！

## 重点回顾

今天，我们讲了为什么要学习设计模式相关的知识，总结一下的话，主要有这样五点：应对面试中的设计模式相关问题；告别写被人吐槽的烂代码；提高复杂代码的设计和开发能力；让读源码、学框架事半功倍；为你的职场发展做铺垫。

投资要趁早，这样我们才能尽早享受复利。同样，有些能力，要早点锻炼；有些东西，要早点知道；有些书，要早点读。这样在你后面的生活、工作、学习中，才能一直都发挥作用。不要等到好多年后，看到了，才恍然大悟，后悔没有早点去学、去看。

设计模式作为一门与编码、开发有着直接关系的基础知识，是你现在就要开始学习的。早点去学习，以后的项目就都可以拿来锻炼，每写一行代码都是对内功的利用和加深，是可以受益一整个职业生涯的事情。

## 课堂讨论

今天课堂讨论的话题有两个：

聊一聊你对设计模式相关知识的重要性的看法；

在你过往的项目开发中，有没有用过某种设计模式？是在什么场景下应用的？解决了什么问题？

笔记：

笔记：
1 作者反复解释了下学好dp 的重要性。

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。
3 show me the code ,你牛不牛，终归还需要代码的展现，把框架说得头头是道又如何，技术看技术，硬核不行，外表的东西白搭。没法成为别人心中的大牛的。

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。
3 show me the code ,你牛不牛，终归还需要代码的展现，把框架说得头头是道又如何，技术看技术，硬核不行，外表的东西白搭。没法成为别人心中的大牛的。
作业：聊看法。

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。
3 show me the code ,你牛不牛，终归还需要代码的展现，把框架说得头头是道又如何，技术看技术，硬核不行，外表的东西白搭。没法成为别人心中的大牛的。
作业：聊看法。
一句话，简直太tmd 的重要了。

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。
3 show me the code ,你牛不牛，终归还需要代码的展现，把框架说得头头是道又如何，技术看技术，硬核不行，外表的东西白搭。没法成为别人心中的大牛的。
作业：聊看法。
一句话，简直太tmd 的重要了。
以前重构过一个p2p 客户投资后奖励活动【放心，平台未跑路，老板是用心做事的人】。 刚开始，他们真的是 if eles 的去写每一个活动。

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。
3 show me the code ,你牛不牛，终归还需要代码的展现，把框架说得头头是道又如何，技术看技术，硬核不行，外表的东西白搭。没法成为别人心中的大牛的。
作业：聊看法。
一句话，简直太tmd 的重要了。
以前重构过一个p2p 客户投资后奖励活动【放心，平台未跑路，老板是用心做事的人】。 刚开始，他们真的是 if eles 的去写每一个活动。
我去了后。主要就是参考yii 框架的实现方法。

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。
3 show me the code ,你牛不牛，终归还需要代码的展现，把框架说得头头是道又如何，技术看技术，硬核不行，外表的东西白搭。没法成为别人心中的大牛的。
作业：聊看法。
一句话，简直太tmd 的重要了。
以前重构过一个p2p 客户投资后奖励活动【放心，平台未跑路，老板是用心做事的人】。 刚开始，他们真的是 if eles 的去写每一个活动。
我去了后。主要就是参考yii 框架的实现方法。
做了以下解藕，把购买后的奖励分为四块。

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。
3 show me the code ,你牛不牛，终归还需要代码的展现，把框架说得头头是道又如何，技术看技术，硬核不行，外表的东西白搭。没法成为别人心中的大牛的。
作业：聊看法。
一句话，简直太tmd 的重要了。
以前重构过一个p2p 客户投资后奖励活动【放心，平台未跑路，老板是用心做事的人】。 刚开始，他们真的是 if eles 的去写每一个活动。
我去了后。主要就是参考yii 框架的实现方法。
做了以下解藕，把购买后的奖励分为四块。
通过配置 rules 来确认是否有奖励资格。 【首次，】

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。
3 show me the code ,你牛不牛，终归还需要代码的展现，把框架说得头头是道又如何，技术看技术，硬核不行，外表的东西白搭。没法成为别人心中的大牛的。
作业：聊看法。
一句话，简直太tmd 的重要了。
以前重构过一个p2p 客户投资后奖励活动【放心，平台未跑路，老板是用心做事的人】。 刚开始，他们真的是 if eles 的去写每一个活动。
我去了后。主要就是参考yii 框架的实现方法。
做了以下解藕，把购买后的奖励分为四块。
通过配置 rules 来确认是否有奖励资格。 【首次，】
清算出奖多少，奖给谁（通常会带上推荐人）【固定额，阶梯算法，比例值，vip 等级等】

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。
3 show me the code ,你牛不牛，终归还需要代码的展现，把框架说得头头是道又如何，技术看技术，硬核不行，外表的东西白搭。没法成为别人心中的大牛的。
作业：聊看法。
一句话，简直太tmd 的重要了。
以前重构过一个p2p 客户投资后奖励活动【放心，平台未跑路，老板是用心做事的人】。 刚开始，他们真的是 if eles 的去写每一个活动。
我去了后。主要就是参考yii 框架的实现方法。
做了以下解藕，把购买后的奖励分为四块。
通过配置 rules 来确认是否有奖励资格。 【首次，】
清算出奖多少，奖给谁（通常会带上推荐人）【固定额，阶梯算法，比例值，vip 等级等】
创建出奖励执行类， （红包，现金，抽奖券 ， 积分等） 并执行奖励

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。
3 show me the code ,你牛不牛，终归还需要代码的展现，把框架说得头头是道又如何，技术看技术，硬核不行，外表的东西白搭。没法成为别人心中的大牛的。
作业：聊看法。
一句话，简直太tmd 的重要了。
以前重构过一个p2p 客户投资后奖励活动【放心，平台未跑路，老板是用心做事的人】。 刚开始，他们真的是 if eles 的去写每一个活动。
我去了后。主要就是参考yii 框架的实现方法。
做了以下解藕，把购买后的奖励分为四块。
通过配置 rules 来确认是否有奖励资格。 【首次，】
清算出奖多少，奖给谁（通常会带上推荐人）【固定额，阶梯算法，比例值，vip 等级等】
创建出奖励执行类， （红包，现金，抽奖券 ， 积分等） 并执行奖励
发送通知 （站内信，短信，微信，邮件 ， ） （通知会在通知里挂接广告）

笔记：
1 作者反复解释了下学好dp 的重要性。
映像深刻的：
基本功不够，把一台战斗机放你面前，你都不知道如何欣赏和品味。
其它职能：
1 面试所需（适当的区分度）
2 告别烂代码，让实现优雅起来。老司机后，要参与指导菜鸟，也要会。
3 show me the code ,你牛不牛，终归还需要代码的展现，把框架说得头头是道又如何，技术看技术，硬核不行，外表的东西白搭。没法成为别人心中的大牛的。
作业：聊看法。
一句话，简直太tmd 的重要了。
以前重构过一个p2p 客户投资后奖励活动【放心，平台未跑路，老板是用心做事的人】。 刚开始，他们真的是 if eles 的去写每一个活动。
我去了后。主要就是参考yii 框架的实现方法。
做了以下解藕，把购买后的奖励分为四块。
通过配置 rules 来确认是否有奖励资格。 【首次，】
清算出奖多少，奖给谁（通常会带上推荐人）【固定额，阶梯算法，比例值，vip 等级等】
创建出奖励执行类， （红包，现金，抽奖券 ， 积分等） 并执行奖励
发送通知 （站内信，短信，微信，邮件 ， ） （通知会在通知里挂接广告）
离开那公司时特意查了一下，公司共发布了1700 条个奖励项，给客户返利约900 万。

2个人认为设计模式主要解决的是扩展和耦合问题

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation
\* 系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation
\* 系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等
使用工厂 + 策略

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation
\* 系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等
使用工厂 + 策略
\* 不同优惠种类的计算

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation
\* 系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等
使用工厂 + 策略
\* 不同优惠种类的计算
\* 定制化功能的解耦

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation
\* 系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等
使用工厂 + 策略
\* 不同优惠种类的计算
\* 定制化功能的解耦
观察者模式：这个模式的思想，我觉得非常的重要，你可以在许多中间件（mq、zookeeper、netty 等等）乃至生活中都能看到它的影子

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation
\* 系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等
使用工厂 + 策略
\* 不同优惠种类的计算
\* 定制化功能的解耦
观察者模式：这个模式的思想，我觉得非常的重要，你可以在许多中间件（mq、zookeeper、netty 等等）乃至生活中都能看到它的影子
\* 通过领域事件解耦业务

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation
\* 系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等
使用工厂 + 策略
\* 不同优惠种类的计算
\* 定制化功能的解耦
观察者模式：这个模式的思想，我觉得非常的重要，你可以在许多中间件（mq、zookeeper、netty 等等）乃至生活中都能看到它的影子
\* 通过领域事件解耦业务
\* 理解 eventloop、epoll 等等

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation
\* 系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等
使用工厂 + 策略
\* 不同优惠种类的计算
\* 定制化功能的解耦
观察者模式：这个模式的思想，我觉得非常的重要，你可以在许多中间件（mq、zookeeper、netty 等等）乃至生活中都能看到它的影子
\* 通过领域事件解耦业务
\* 理解 eventloop、epoll 等等
\* 通过 watch 实现动态配置、HA 等等

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation
\* 系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等
使用工厂 + 策略
\* 不同优惠种类的计算
\* 定制化功能的解耦
观察者模式：这个模式的思想，我觉得非常的重要，你可以在许多中间件（mq、zookeeper、netty 等等）乃至生活中都能看到它的影子
\* 通过领域事件解耦业务
\* 理解 eventloop、epoll 等等
\* 通过 watch 实现动态配置、HA 等等
责任链模式：pipeline 思想

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation
\* 系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等
使用工厂 + 策略
\* 不同优惠种类的计算
\* 定制化功能的解耦
观察者模式：这个模式的思想，我觉得非常的重要，你可以在许多中间件（mq、zookeeper、netty 等等）乃至生活中都能看到它的影子
\* 通过领域事件解耦业务
\* 理解 eventloop、epoll 等等
\* 通过 watch 实现动态配置、HA 等等
责任链模式：pipeline 思想
\* filter

个人认为设计模式主要解决的是扩展和耦合问题
日常使用：
使用代理模式进行共性化处理，比如说 AOP 思想，将非业务功能和业务功能解耦
\* 事务的处理@Translation
\* 系统间上下文的传递 ThreadLocal + restTemplate#intercept 等等
使用工厂 + 策略
\* 不同优惠种类的计算
\* 定制化功能的解耦
观察者模式：这个模式的思想，我觉得非常的重要，你可以在许多中间件（mq、zookeeper、netty 等等）乃至生活中都能看到它的影子
\* 通过领域事件解耦业务
\* 理解 eventloop、epoll 等等
\* 通过 watch 实现动态配置、HA 等等
责任链模式：pipeline 思想
\* filter
\* 理解 netty 中的各种 handler

1、设计模式的重要性看法：

1、设计模式的重要性看法：
(1)可以使得代码编写更优雅

1、设计模式的重要性看法：
(1)可以使得代码编写更优雅
(2)对学习一些开源框架有很大帮助

1、设计模式的重要性看法：
(1)可以使得代码编写更优雅
(2)对学习一些开源框架有很大帮助
(3)程序的可扩展性、维护性更好，系统解耦

1、设计模式的重要性看法：
(1)可以使得代码编写更优雅
(2)对学习一些开源框架有很大帮助
(3)程序的可扩展性、维护性更好，系统解耦
2、基于上面的看法结合实际项目说明：

1、设计模式的重要性看法：
(1)可以使得代码编写更优雅
(2)对学习一些开源框架有很大帮助
(3)程序的可扩展性、维护性更好，系统解耦
2、基于上面的看法结合实际项目说明：
(1)在新老系统接割的项目中，进行数据回写，用到了策略模式，根据不同的接口码值，进行不同的策略回写。

1、设计模式的重要性看法：
(1)可以使得代码编写更优雅
(2)对学习一些开源框架有很大帮助
(3)程序的可扩展性、维护性更好，系统解耦
2、基于上面的看法结合实际项目说明：
(1)在新老系统接割的项目中，进行数据回写，用到了策略模式，根据不同的接口码值，进行不同的策略回写。
(2)在银行前置系统中，用到了模板设计模式，对接不同的三方通道，在模板中定义某些特定的步骤，并加上hook，具体步骤子类实现。

1、设计模式的重要性看法：
(1)可以使得代码编写更优雅
(2)对学习一些开源框架有很大帮助
(3)程序的可扩展性、维护性更好，系统解耦
2、基于上面的看法结合实际项目说明：
(1)在新老系统接割的项目中，进行数据回写，用到了策略模式，根据不同的接口码值，进行不同的策略回写。
(2)在银行前置系统中，用到了模板设计模式，对接不同的三方通道，在模板中定义某些特定的步骤，并加上hook，具体步骤子类实现。
(3)责任链模式，在网关系统中用到的filter就是责任链模式，把一个请求依次的在过滤器链上进行传输

1、设计模式的重要性看法：
(1)可以使得代码编写更优雅
(2)对学习一些开源框架有很大帮助
(3)程序的可扩展性、维护性更好，系统解耦
2、基于上面的看法结合实际项目说明：
(1)在新老系统接割的项目中，进行数据回写，用到了策略模式，根据不同的接口码值，进行不同的策略回写。
(2)在银行前置系统中，用到了模板设计模式，对接不同的三方通道，在模板中定义某些特定的步骤，并加上hook，具体步骤子类实现。
(3)责任链模式，在网关系统中用到的filter就是责任链模式，把一个请求依次的在过滤器链上进行传输
(4)装饰器模式，在普通的微服务提供的restful接口中，在请求返回的时给对象添加一些额外的职责

1、设计模式的重要性看法：
(1)可以使得代码编写更优雅
(2)对学习一些开源框架有很大帮助
(3)程序的可扩展性、维护性更好，系统解耦
2、基于上面的看法结合实际项目说明：
(1)在新老系统接割的项目中，进行数据回写，用到了策略模式，根据不同的接口码值，进行不同的策略回写。
(2)在银行前置系统中，用到了模板设计模式，对接不同的三方通道，在模板中定义某些特定的步骤，并加上hook，具体步骤子类实现。
(3)责任链模式，在网关系统中用到的filter就是责任链模式，把一个请求依次的在过滤器链上进行传输
(4)装饰器模式，在普通的微服务提供的restful接口中，在请求返回的时给对象添加一些额外的职责
(5)门面设计模式，对外提供统一的接口，例如在springcloud中提供统一的feinclient接口，所有外部系统都通过feinclient接口进行接入，从而不关心内部接口的调用实现。

1、设计模式的重要性看法：
(1)可以使得代码编写更优雅
(2)对学习一些开源框架有很大帮助
(3)程序的可扩展性、维护性更好，系统解耦
2、基于上面的看法结合实际项目说明：
(1)在新老系统接割的项目中，进行数据回写，用到了策略模式，根据不同的接口码值，进行不同的策略回写。
(2)在银行前置系统中，用到了模板设计模式，对接不同的三方通道，在模板中定义某些特定的步骤，并加上hook，具体步骤子类实现。
(3)责任链模式，在网关系统中用到的filter就是责任链模式，把一个请求依次的在过滤器链上进行传输
(4)装饰器模式，在普通的微服务提供的restful接口中，在请求返回的时给对象添加一些额外的职责
(5)门面设计模式，对外提供统一的接口，例如在springcloud中提供统一的feinclient接口，所有外部系统都通过feinclient接口进行接入，从而不关心内部接口的调用实现。
(6)还有命令设计模式，原来在看工作流的时候不知道这个模式，看的云里雾里，后来才知道原来整个框架用到了命令设计模式，一下子就明朗了很多。所以学习设计模式很重要。

1、设计模式的重要性看法：
(1)可以使得代码编写更优雅
(2)对学习一些开源框架有很大帮助
(3)程序的可扩展性、维护性更好，系统解耦
2、基于上面的看法结合实际项目说明：
(1)在新老系统接割的项目中，进行数据回写，用到了策略模式，根据不同的接口码值，进行不同的策略回写。
(2)在银行前置系统中，用到了模板设计模式，对接不同的三方通道，在模板中定义某些特定的步骤，并加上hook，具体步骤子类实现。
(3)责任链模式，在网关系统中用到的filter就是责任链模式，把一个请求依次的在过滤器链上进行传输
(4)装饰器模式，在普通的微服务提供的restful接口中，在请求返回的时给对象添加一些额外的职责
(5)门面设计模式，对外提供统一的接口，例如在springcloud中提供统一的feinclient接口，所有外部系统都通过feinclient接口进行接入，从而不关心内部接口的调用实现。
(6)还有命令设计模式，原来在看工作流的时候不知道这个模式，看的云里雾里，后来才知道原来整个框架用到了命令设计模式，一下子就明朗了很多。所以学习设计模式很重要。
还有单例模式、工厂模式等，以上大概就是在工作中用到的设计模式，分享一下，如有不对请指正。







# 02 | 从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？

王争 2019-11-04

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：16.95M 时长：18:30

在我的工作经历中，每当同事评论起项目代码质量的时候，听到的最多的评语就是：“代码写得很烂”或者“代码写得很好”。用“好”“烂”这样的字眼来描述，非常地笼统。当我具体问到底如何烂、如何好的时候，尽管大部分同事都能简单地罗列上几个点，但往往都不够全面、非常零碎，也切不中要害。

当然，也有一些工程师对如何评价代码质量有所认识，比如，好代码是易扩展、易读、简单、易维护的等等，但他们对于这些评价的理解往往只停留在表面概念上，对于诸多更深入的问题，比如，“怎么才算可读性好？什么样的代码才算易扩展、易维护？可读、可扩展与可维护之间有什么关系？可维护中‘维护’两字该如何理解？”等等，并没有太清晰的认识。

对于程序员来说，辨别代码写得“好”还是“烂”，是一个非常重要的能力。这也是我们写出好代码的前提。毕竟，如果我们连什么是好代码、什么是烂代码，都分辨不清，又谈何写出好代码呢？

所以，今天我们就聊一聊关于代码质量评判的相关问题，希望你在学完今天的内容之后，对代码质量的评判有个更加清晰、更加透彻的认识和理解。

## 如何评价代码质量的高低？

实际上，咱们平时嘴中常说的“好”和“烂”，是对代码质量的一种描述。“好”笼统地表示代码质量高，“烂”笼统地表示代码质量低。对于代码质量的描述，除了“好”“烂”这样比较简单粗暴的描述方式之外，我们也经常会听到很多其他的描述方式。这些描述方法语义更丰富、更专业、更细化。我搜集整理了一下，罗列在了下面。这些几乎涵盖我们所能听到的描述代码质量的所有常用词汇，你可以看一看。

灵活性（flexibility）、可扩展性（extensibility）、可维护性（maintainability）、可读性（readability）、可理解性（understandability）、易修改性（changeability）、可复用（reusability）、可测试性（testability）、模块化（modularity）、高内聚低耦合（high cohesion loose coupling）、高效（high effciency）、高性能（high performance）、安全性（security）、兼容性（compatibility）、易用性（usability）、整洁（clean）、清晰（clarity）、简单（simple）、直接（straightforward）、少即是多（less code is more）、文档详尽（well-documented）、分层清晰（well-layered）、正确性（correctness、bug free）、健壮性（robustness）、鲁棒性（robustness）、可用性（reliability）、可伸缩性（scalability）、稳定性（stability）、优雅（elegant）、好（good）、坏（bad）……

看到如此多的描述词，你可能要问了，我们到底该用哪些词来描述一段代码的质量呢？

实际上，我们很难通过其中的某个或者某几个词汇来全面地评价代码质量。因为这些词汇都是从不同维度来说的。这就好比，对于一个人的评价，我们需要综合各个方面来给出，比如性格、相貌、能力、财富等等。代码质量高低也是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码写的好坏。比如，即使一段代码的可扩展性很好，但可读性很差，那我们也不能说这段代码质量高。

除此之外，不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。比如，代码的可读性好、可扩展性好，就意味着代码的可维护性好。而且，各种评价维度也不是非黑即白的。比如，我们不能简单地将代码分为可读与不可读。如果用数字来量化代码的可读性的话，它应该是一个连续的区间值，而非 0、1 这样的离散值。

不过，我们真的可以客观地量化一段代码质量的高低吗？答案是否定的。对一段代码的质量评价，常常有很强的主观性。比如，怎么样的代码才算可读性好，每个人的评判标准都不大一样。这就好比我们去评价一本小说写得是否精彩，本身就是一个很难量化的、非常主观的事情。

正是因为代码质量评价的主观性，使得这种主观评价的准确度，跟工程师自身经验有极大的关系。越是有经验的工程师，给出的评价也就越准确。相反，资历比较浅的工程师就常常会觉得，没有一个可执行的客观的评价标准作为参考，很难准确地判断一段代码写得好与坏。有的时候，自己觉得代码写得已经够好了，但实际上并不是。所以，这也导致如果没有人指导的话，自己一个人闷头写代码，即便写再多的代码，代码能力也可能一直没有太大提高。

## 最常用的评价标准有哪几个？

仔细看前面罗列的所有代码质量评价标准，你会发现，有些词语过于笼统、抽象，比较偏向对于整体的描述，比如优雅、好、坏、整洁、清晰等；有些过于细节、偏重方法论，比如模块化、高内聚低耦合、文档详尽、分层清晰等；有些可能并不仅仅局限于编码，跟架构设计等也有关系，比如可伸缩性、可用性、稳定性等。

为了做到有的放矢、有重点地学习，我挑选了其中几个最常用的、最重要的评价标准，来详细讲解，其中就包括：可维护性、可读性、可扩展性、灵活性、简洁性（简单、复杂）、可复用性、可测试性。接下来，我们逐一讲解一下。

### 1. 可维护性（maintainability）

我们首先来看，什么是代码的“可维护性”？所谓的“维护代码”到底包含哪些具体工作？

落实到编码开发，所谓的“维护”无外乎就是修改 bug、修改老的代码、添加新的代码之类的工作。所谓“代码易维护”就是指，在不破坏原有代码设计、不引入新的 bug 的情况下，能够快速地修改或者添加代码。所谓“代码不易维护”就是指，修改或者添加代码需要冒着极大的引入新 bug 的风险，并且需要花费很长的时间才能完成。

我们知道，对于一个项目来说，维护代码的时间远远大于编写代码的时间。工程师大部分的时间可能都是花在修修 bug、改改老的功能逻辑、添加一些新的功能逻辑之类的工作上。所以，代码的可维护性就显得格外重要。

维护、易维护、不易维护这三个概念不难理解。不过，对于实际的软件开发来说，更重要的是搞清楚，如何来判断代码可维护性的好坏。

实际上，可维护性也是一个很难量化、偏向对代码整体的评价标准，它有点类似之前提到的“好”“坏”“优雅”之类的笼统评价。代码的可维护性是由很多因素协同作用的结果。代码的可读性好、简洁、可扩展性好，就会使得代码易维护；相反，就会使得代码不易维护。更细化地讲，如果代码分层清晰、模块化好、高内聚低耦合、遵从基于接口而非实现编程的设计原则等等，那就可能意味着代码易维护。除此之外，代码的易维护性还跟项目代码量的多少、业务的复杂程度、利用到的技术的复杂程度、文档是否全面、团队成员的开发水平等诸多因素有关。

所以，从正面去分析一个代码是否易维护稍微有点难度。不过，我们可以从侧面上给出一个比较主观但又比较准确的感受。如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个 bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。

你可能会说，这样的评价方式也太主观了吧？没错，是否易维护本来就是针对维护的人来说的。不同水平的人对于同一份代码的维护能力并不是相同的。对于同样一个系统，熟悉它的资深工程师会觉得代码的可维护性还不错，而一些新人因为不熟悉代码，修改 bug、修改添加代码要花费很长的时间，就有可能会觉得代码的可维护性不那么好。这实际上也印证了我们之前的观点：代码质量的评价有很强的主观性。

### 2. 可读性（readability）

软件设计大师 Martin Fowler 曾经说过：“Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”翻译成中文就是：“任何傻瓜都会编写计算机能理解的代码。好的程序员能够编写人能够理解的代码。”Google 内部甚至专门有个认证就叫作 Readability。只有拿到这个认证的工程师，才有资格在 code review 的时候，批准别人提交代码。可见代码的可读性有多重要，毕竟，代码被阅读的次数远远超过被编写和执行的次数。

我个人认为，代码的可读性应该是评价代码质量最重要的指标之一。我们在编写代码的时候，时刻要考虑到代码是否易读、易理解。除此之外，代码的可读性在非常大程度上会影响代码的可维护性。毕竟，不管是修改 bug，还是修改添加功能代码，我们首先要做的事情就是读懂代码。代码读不大懂，就很有可能因为考虑不周全，而引入新的 bug。

既然可读性如此重要，那我们又该如何评价一段代码的可读性呢？

我们需要看代码是否符合编码规范、命名是否达意、注释是否详尽、函数是否长短合适、模块划分是否清晰、是否符合高内聚低耦合等等。你应该也能感觉到，从正面上，我们很难给出一个覆盖所有评价指标的列表。这也是我们无法量化可读性的原因。

实际上，code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。

### 3. 可扩展性（extensibility）

可扩展性也是一个评价代码质量非常重要的标准。它表示我们的代码应对未来需求变化的能力。跟可读性一样，代码是否易扩展也很大程度上决定代码是否易维护。那到底什么是代码的可扩展性呢？

代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。

关于代码的扩展性，在后面讲到“对修改关闭，对扩展开放”这条设计原则的时候，我会来详细讲解，今天我们只需要知道，代码的可扩展性是评价代码质量非常重要的标准就可以了。

### 4. 灵活性（flexibility）

灵活性也是描述代码质量的一个常用词汇。比如我们经常会听到这样的描述：“代码写得很灵活”。那这里的“灵活”该如何理解呢？

尽管有很多人用这个词汇来描述代码的质量。但实际上，灵活性是一个挺抽象的评价标准，要给灵活性下个定义也是挺难的。不过，我们可以想一下，什么情况下我们才会说代码写得好灵活呢？我这里罗列了几个场景，希望能引发你自己对什么是灵活性的思考。

当我们添加一个新的功能代码的时候，原有的代码已经预留好了扩展点，我们不需要修改原有的代码，只要在扩展点上添加新的代码即可。这个时候，我们除了可以说代码易扩展，还可以说代码写得好灵活。

当我们要实现一个功能的时候，发现原有代码中，已经抽象出了很多底层可以复用的模块、类等代码，我们可以拿来直接使用。这个时候，我们除了可以说代码易复用之外，还可以说代码写得好灵活。

当我们使用某组接口的时候，如果这组接口可以应对各种使用场景，满足各种不同的需求，我们除了可以说接口易用之外，还可以说这个接口设计得好灵活或者代码写得好灵活。

从刚刚举的场景来看，如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。所以，灵活这个词的含义非常宽泛，很多场景下都可以使用。

### 5. 简洁性（simplicity）

有一条非常著名的设计原则，你一定听过，那就是 KISS 原则：“Keep It Simple，Stupid”。这个原则说的意思就是，尽量保持代码简单。代码简单、逻辑清晰，也就意味着易读、易维护。我们在编写代码的时候，往往也会把简单、清晰放到首位。

不过，很多编程经验不足的程序员会觉得，简单的代码没有技术含量，喜欢在项目中引入一些复杂的设计模式，觉得这样才能体现自己的技术水平。实际上，思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。

除此之外，虽然我们都能认识到，代码要尽量写得简洁，符合 KISS 原则，但怎么样的代码才算足够简洁？不是每个人都能很准确地判断出来这一点。所以，在后面的章节中，当我们讲到 KISS 原则的时候，我会通过具体的代码实例，详细给你解释，“为什么 KISS 原则看似非常简单、好理解，但实际上用好并不容易”。今天，我们就暂且不展开详细讲解了。

### 6. 可复用性（reusability）

代码的可复用性可以简单地理解为，尽量减少重复代码的编写，复用已有的代码。在后面的很多章节中，我们都会经常提到“可复用性”这一代码评价标准。

比如，当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。可见，可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果。

实际上，代码可复用性跟 DRY（Don’t Repeat Yourself）这条设计原则的关系挺紧密的，所以，在后面的章节中，当我们讲到 DRY 设计原则的时候，我还会讲更多代码复用相关的知识，比如，“有哪些编程方法可以提高代码的复用性”等。

### 7. 可测试性（testability）

相对于前面六个评价标准，代码的可测试性是一个相对较少被提及，但又非常重要的代码质量评价标准。代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。关于代码的可测试性，我们在重构那一部分，会花两节课的时间来详细讲解。现在，你暂时只需要知道，代码的可测试性非常重要就可以了。

## 如何才能写出高质量的代码？

我相信每个工程师都想写出高质量的代码，不想一直写没有成长、被人吐槽的烂代码。那如何才能写出高质量的代码呢？针对什么是高质量的代码，我们刚刚讲到了七个最常用、最重要的评价指标。所以，问如何写出高质量的代码，也就等同于在问，如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。

要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。而所有这些编程方法论的最终目的都是为了编写出高质量的代码。

比如，面向对象中的继承、多态能让我们写出可复用的代码；编码规范能让我们写出可读性好的代码；设计原则中的单一职责、DRY、基于接口而非实现、里式替换原则等，可以让我们写出可复用、灵活、可读性好、易扩展、易维护的代码；设计模式可以让我们写出易扩展的代码；持续重构可以时刻保持代码的可维护性等等。具体这些编程方法论是如何提高代码的可维护性、可读性、可扩展性等等的呢？我们在后面的课程中慢慢来学习。

## 重点回顾

今天的内容到此就讲完了。我们来一起回顾一下，你需要重点掌握的几个知识点。

\1. 如何评价代码质量的高低？

代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁等，这些词汇是从不同的维度去评价代码质量的。它们之间有互相作用，并不是独立的，比如，代码的可读性好、可扩展性好就意味着代码的可维护性好。代码质量高低是一个综合各种因素得到的结论。我们并不能通过单一的维度去评价一段代码的好坏。

\2. 最常用的评价标准有哪几个？

最常用到几个评判代码质量的标准是：可维护性、可读性、可扩展性、灵活性、简洁性、可复用性、可测试性。其中，可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。

\3. 如何才能写出高质量的代码？

要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等等，这也是我们后面课程学习的重点。

## 课堂讨论

除了我今天提到的这些，你觉得还有哪些其他的代码评价标准非常重要？聊一聊你心目中的好代码是什么样子的？





# 03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？

王争 2019-11-04

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAABCAYAAACc0f2yAAAAJElEQVQYV2N89+7df0FBQQYQeP/+PZgGAWQxUtmEzCBHnpAeANOKKsuvlr7QAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAAH0lEQVQYV2N89+7df0FBQQYQeP/+PZgGAUJiyPLIbAAO0BLLZHBegQAAAABJRU5ErkJggg==)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAABCAYAAACCGM0BAAAALUlEQVQYV2N89+7df0FBQQYQeP/+PQMyGyzIwEBQDJd+QmaRIk9ILTa3YtMDAKTbMMuTn85fAAAAAElFTkSuQmCC)![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAABCAYAAADErm6rAAAAH0lEQVQYV2N89+7dfwYoEBQUBLPev3/PgIuNTS0+MQAjjxLLknDCbgAAAABJRU5ErkJggg==)



00:00

1.0x**

讲述：冯永吉 大小：10.27M 时长：11:12

在上一节课中，我们讲到，要具备编写高质量代码的能力，你需要学习一些编程方法论，其中就包含面向对象（我们可以把它看成一种设计思想）、设计原则、设计模式、编程规范、重构技巧等。而我们整个专栏的内容也是围绕着这几块展开讲解的。所以，今天我就先来简单介绍一下这几个概念，并且说一说它们之间的联系。

今天的内容相当于专栏的一个教学大纲，或者说学习框架。它能让你对整个专栏所涉及的知识点，有一个全局性的了解，能帮你将后面零散的知识更系统地组织在大脑里。

话不多说，我们就一块来看一下，接下来的这 8 个月我们到底要学习哪些内容吧！

## 面向对象

现在，主流的编程范式或者是编程风格有三种，它们分别是面向过程、面向对象和函数式编程。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。

所以，在专栏的最开始，我们会详细地讲解面向对象编程的相关的知识，为学习后面的内容做铺垫。对于这部分内容，你需要掌握下面这 7 个大的知识点。

面向对象的四大特性：封装、抽象、继承、多态

面向对象编程与面向过程编程的区别和联系

面向对象分析、面向对象设计、面向对象编程

接口和抽象类的区别以及各自的应用场景

基于接口而非实现编程的设计思想

多用组合少用继承的设计思想

面向过程的贫血模型和面向对象的充血模型

## 设计原则

设计原则是指导我们代码设计的一些经验总结。设计原则这块儿的知识有一个非常大的特点，那就是这些原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。所以，如果单纯地去记忆定义，对于编程、设计能力的提高，意义并不大。对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。只有这样，我们才能在项目中灵活恰当地应用这些原则。

对于这一部分内容，你需要透彻理解并且掌握，如何应用下面这样几个常用的设计原则。

SOLID 原则 -SRP 单一职责原则

SOLID 原则 -OCP 开闭原则

SOLID 原则 -LSP 里式替换原则

SOLID 原则 -ISP 接口隔离原则

SOLID 原则 -DIP 依赖倒置原则

DRY 原则、KISS 原则、YAGNI 原则、LOD 法则

## 设计模式

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。大部分设计模式要解决的都是代码的可扩展性问题。设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。

经典的设计模式有 23 种。随着编程语言的演进，一些设计模式（比如 Singleton）也随之过时，甚至成了反模式，一些则被内置在编程语言中（比如 Iterator），另外还有一些新的模式诞生（比如 Monostate）。

在专栏中，我们会重点讲解 23 种经典的设计模式。它们又可以分为三大类：创建型、结构型、行为型。对于这 23 种设计模式的学习，我们要有侧重点，因为有些模式是比较常用的，有些模式是很少被用到的。对于常用的设计模式，我们要花多点时间理解掌握。对于不常用的设计模式，我们只需要稍微了解即可。

我按照类型和是否常用，对专栏中讲到的这些设计模式，进行了简单的分类，具体如下所示。

### 1. 创建型

常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。

不常用的有：原型模式。

### 2. 结构型

常用的有：代理模式、桥接模式、装饰者模式、适配器模式。

不常用的有：门面模式、组合模式、享元模式。

### 3. 行为型

常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。

不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。

## 编程规范

编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。即便你可能对设计原则不熟悉、对设计模式不了解，但你最起码要掌握基本的编码规范，比如，如何给变量、类、函数命名，如何写代码注释，函数不宜过长、参数不能过多等等。

对于编码规范，考虑到很多书籍已经讲得很好了（比如《重构》《代码大全》《代码整洁之道》等）。而且，每条编码规范都非常简单、非常明确，比较偏向于记忆，你只要照着来做可以。它不像设计原则，需要融入很多个人的理解和思考。所以，在这个专栏中，我并没有花太多的篇幅来讲解所有的编码规范，而是总结了我认为的最能改善代码质量的 20 条规范。如果你暂时没有时间去看那些经典的书籍，看我这些就够了。

除此之外，专栏并没有将编码规范单独作为一个模块来讲解，而是跟重构放到了一起。之所以这样做，那是因为我把重构分为大重构和小重构两种类型，而小重构利用的知识基本上就是编码规范。

除了编码规范，我们还会介绍一些代码的坏味道，让你知道什么样的代码是不符合规范的，应该如何优化。参照编码规范，你可以写出可读性好的代码；参照代码的坏味道，你可以找出代码存在的可读性问题。

## 代码重构

在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。持续重构是保持代码质量不下降的有效手段，能有效避免代码腐化到无可救药的地步。

而重构的工具就是我们前面罗列的那些面向对象设计思想、设计原则、设计模式、编码规范。实际上，设计思想、设计原则、设计模式一个最重要的应用场景就是在重构的时候。我们前面讲过，虽然使用设计模式可以提高代码的可扩展性，但过度不恰当地使用，也会增加代码的复杂度，影响代码的可读性。在开发初期，除非特别必须，我们一定不要过度设计，应用复杂的设计模式。而是当代码出现问题的时候，我们再针对问题，应用原则和模式进行重构。这样就能有效避免前期的过度设计。

对于重构这部分内容，你需要掌握以下几个知识点：

重构的目的（why）、对象（what）、时机（when）、方法（how）；

保证重构不出错的技术手段：单元测试和代码的可测试性；

两种不同规模的重构：大重构（大规模高层次）和小重构（小规模低层次）。

希望你学完这部分内容之后，不仅仅是掌握一些重构技巧、套路，更重要的是建立持续重构意识，把重构当作开发的一部分，融入到日常的开发中。

## 五者之间的联系

关于面向对象、设计原则、设计模式、编程规范和代码重构，这五者的关系我们前面稍微提到了一些，我这里再总结梳理一下。

面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式等编码实现的基础。

设计原则是指导我们代码设计的一些经验总结，对于某些场景下，是否应该应用某种设计模式，具有指导意义。比如，“开闭原则”是很多设计模式（策略、模板等）的指导原则。

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。应用设计模式的主要目的是提高代码的可扩展性。从抽象程度上来讲，设计原则比设计模式更抽象。设计模式更加具体、更加可执行。

编程规范主要解决的是代码的可读性问题。编码规范相对于设计原则、设计模式，更加具体、更加偏重代码细节、更加能落地。持续的小重构依赖的理论基础主要就是编程规范。

重构作为保持代码质量不下降的有效手段，利用的就是面向对象、设计原则、设计模式、编码规范这些理论。

实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。当我们追本逐源，看清这个本质之后，很多事情怎么做就清楚了，很多选择怎么选也清楚了。比如，在某个场景下，该不该用这个设计模式，那就看能不能提高代码的可扩展性；要不要重构，那就看重代码是否存在可读、可维护问题等。

## 重点回顾

今天的内容到此就讲完了。我画了一张图，总结了专栏中所涉及的知识点。在学习后面的课程的时候，你可以经常翻出来看一下，建立全局意识，不至于迷失在零碎的知识点中。

![](https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png)

## 课堂讨论

今天课堂讨论的话题有两个。

在今天讲到的内容中，你觉得哪一部分内容对提高代码质量最有效？为什么？除了我罗列的这些内容之外，你还知道哪些可以提高代码质量的方法？

我们知道，最经典的设计模式书籍是 GoF 的《设计模式》，它的中文全称是《设计模式：可复用面向对象软件的基础》，英文全称是“Design Patterns: Elements of Reusable Object-Oriented Software”。为什么它在标题中会特意提到“面向对象”呢？

我觉得今年对我来说，是重新认识“面向对象”的一年。

我觉得今年对我来说，是重新认识“面向对象”的一年。
今年事我工作的第三年了（从八月份开始算第三年），年初的时候误打误撞的学了一段时间的DDD，让我瞬间感受到了什么才是面向对象编程，之前自己做的都是用面向对象的语言写面向过程的代码。究其原因，可能是MVC 三层架构的影响，太多人的代码里头只剩下了pojo这种贫血模型。封装，继承，多态，抽象是啥，早就忘干净了。

我觉得今年对我来说，是重新认识“面向对象”的一年。
今年事我工作的第三年了（从八月份开始算第三年），年初的时候误打误撞的学了一段时间的DDD，让我瞬间感受到了什么才是面向对象编程，之前自己做的都是用面向对象的语言写面向过程的代码。究其原因，可能是MVC 三层架构的影响，太多人的代码里头只剩下了pojo这种贫血模型。封装，继承，多态，抽象是啥，早就忘干净了。
在软件设计方面，很多人习惯了一开始就设计数据库表结构，结果就是代码逻辑跟数据库构成了强耦合，数据库一改，代码基本上会被改个彻底。在这种情况下，我们用的java面向对象的语言，结果却写的是面向过程的代码，这种代码基本没有可维护，可扩展，更没有可测试性一说。所以，面向对象的这个词语，被太多的人只是挂在嘴边上了，落实到代码里边，就成了面向过程。

我觉得今年对我来说，是重新认识“面向对象”的一年。
今年事我工作的第三年了（从八月份开始算第三年），年初的时候误打误撞的学了一段时间的DDD，让我瞬间感受到了什么才是面向对象编程，之前自己做的都是用面向对象的语言写面向过程的代码。究其原因，可能是MVC 三层架构的影响，太多人的代码里头只剩下了pojo这种贫血模型。封装，继承，多态，抽象是啥，早就忘干净了。
在软件设计方面，很多人习惯了一开始就设计数据库表结构，结果就是代码逻辑跟数据库构成了强耦合，数据库一改，代码基本上会被改个彻底。在这种情况下，我们用的java面向对象的语言，结果却写的是面向过程的代码，这种代码基本没有可维护，可扩展，更没有可测试性一说。所以，面向对象的这个词语，被太多的人只是挂在嘴边上了，落实到代码里边，就成了面向过程。
在意识到这个问题后，我花了一段时间重新回顾了一遍面向对象的知识，并试图用来改进代码质量，这个过程是充满坎坷的，我总结了一些自己的体会：

我觉得今年对我来说，是重新认识“面向对象”的一年。
今年事我工作的第三年了（从八月份开始算第三年），年初的时候误打误撞的学了一段时间的DDD，让我瞬间感受到了什么才是面向对象编程，之前自己做的都是用面向对象的语言写面向过程的代码。究其原因，可能是MVC 三层架构的影响，太多人的代码里头只剩下了pojo这种贫血模型。封装，继承，多态，抽象是啥，早就忘干净了。
在软件设计方面，很多人习惯了一开始就设计数据库表结构，结果就是代码逻辑跟数据库构成了强耦合，数据库一改，代码基本上会被改个彻底。在这种情况下，我们用的java面向对象的语言，结果却写的是面向过程的代码，这种代码基本没有可维护，可扩展，更没有可测试性一说。所以，面向对象的这个词语，被太多的人只是挂在嘴边上了，落实到代码里边，就成了面向过程。
在意识到这个问题后，我花了一段时间重新回顾了一遍面向对象的知识，并试图用来改进代码质量，这个过程是充满坎坷的，我总结了一些自己的体会：
1： 要真正落地面向对象编程，面向对象设计是前提，没有面向对象的设计意识，写着写着就成了面条代码。

我觉得今年对我来说，是重新认识“面向对象”的一年。
今年事我工作的第三年了（从八月份开始算第三年），年初的时候误打误撞的学了一段时间的DDD，让我瞬间感受到了什么才是面向对象编程，之前自己做的都是用面向对象的语言写面向过程的代码。究其原因，可能是MVC 三层架构的影响，太多人的代码里头只剩下了pojo这种贫血模型。封装，继承，多态，抽象是啥，早就忘干净了。
在软件设计方面，很多人习惯了一开始就设计数据库表结构，结果就是代码逻辑跟数据库构成了强耦合，数据库一改，代码基本上会被改个彻底。在这种情况下，我们用的java面向对象的语言，结果却写的是面向过程的代码，这种代码基本没有可维护，可扩展，更没有可测试性一说。所以，面向对象的这个词语，被太多的人只是挂在嘴边上了，落实到代码里边，就成了面向过程。
在意识到这个问题后，我花了一段时间重新回顾了一遍面向对象的知识，并试图用来改进代码质量，这个过程是充满坎坷的，我总结了一些自己的体会：
1： 要真正落地面向对象编程，面向对象设计是前提，没有面向对象的设计意识，写着写着就成了面条代码。
2：以前只知道封装、继承、多态，全然忽视了最重要的抽象，抽象是封装、继承、和多态的基础。合理的抽象源于对业务主体的合理分析和认识。合理的抽象，应该是自洽的，易于理解的。

我觉得今年对我来说，是重新认识“面向对象”的一年。
今年事我工作的第三年了（从八月份开始算第三年），年初的时候误打误撞的学了一段时间的DDD，让我瞬间感受到了什么才是面向对象编程，之前自己做的都是用面向对象的语言写面向过程的代码。究其原因，可能是MVC 三层架构的影响，太多人的代码里头只剩下了pojo这种贫血模型。封装，继承，多态，抽象是啥，早就忘干净了。
在软件设计方面，很多人习惯了一开始就设计数据库表结构，结果就是代码逻辑跟数据库构成了强耦合，数据库一改，代码基本上会被改个彻底。在这种情况下，我们用的java面向对象的语言，结果却写的是面向过程的代码，这种代码基本没有可维护，可扩展，更没有可测试性一说。所以，面向对象的这个词语，被太多的人只是挂在嘴边上了，落实到代码里边，就成了面向过程。
在意识到这个问题后，我花了一段时间重新回顾了一遍面向对象的知识，并试图用来改进代码质量，这个过程是充满坎坷的，我总结了一些自己的体会：
1： 要真正落地面向对象编程，面向对象设计是前提，没有面向对象的设计意识，写着写着就成了面条代码。
2：以前只知道封装、继承、多态，全然忽视了最重要的抽象，抽象是封装、继承、和多态的基础。合理的抽象源于对业务主体的合理分析和认识。合理的抽象，应该是自洽的，易于理解的。
3：关于组合和聚合的关系，最核心的区别就是生命周期的区别，组合关系中，整体和部分是一个整体，离开了整体，部分没有意义，同时产生，同时销毁，而聚合关系中，部分单独存在也可以是有意义的。

我觉得今年对我来说，是重新认识“面向对象”的一年。
今年事我工作的第三年了（从八月份开始算第三年），年初的时候误打误撞的学了一段时间的DDD，让我瞬间感受到了什么才是面向对象编程，之前自己做的都是用面向对象的语言写面向过程的代码。究其原因，可能是MVC 三层架构的影响，太多人的代码里头只剩下了pojo这种贫血模型。封装，继承，多态，抽象是啥，早就忘干净了。
在软件设计方面，很多人习惯了一开始就设计数据库表结构，结果就是代码逻辑跟数据库构成了强耦合，数据库一改，代码基本上会被改个彻底。在这种情况下，我们用的java面向对象的语言，结果却写的是面向过程的代码，这种代码基本没有可维护，可扩展，更没有可测试性一说。所以，面向对象的这个词语，被太多的人只是挂在嘴边上了，落实到代码里边，就成了面向过程。
在意识到这个问题后，我花了一段时间重新回顾了一遍面向对象的知识，并试图用来改进代码质量，这个过程是充满坎坷的，我总结了一些自己的体会：
1： 要真正落地面向对象编程，面向对象设计是前提，没有面向对象的设计意识，写着写着就成了面条代码。
2：以前只知道封装、继承、多态，全然忽视了最重要的抽象，抽象是封装、继承、和多态的基础。合理的抽象源于对业务主体的合理分析和认识。合理的抽象，应该是自洽的，易于理解的。
3：关于组合和聚合的关系，最核心的区别就是生命周期的区别，组合关系中，整体和部分是一个整体，离开了整体，部分没有意义，同时产生，同时销毁，而聚合关系中，部分单独存在也可以是有意义的。
4：别滥用继承，继承的作用更多的时候使用多态的特性。

我觉得今年对我来说，是重新认识“面向对象”的一年。
今年事我工作的第三年了（从八月份开始算第三年），年初的时候误打误撞的学了一段时间的DDD，让我瞬间感受到了什么才是面向对象编程，之前自己做的都是用面向对象的语言写面向过程的代码。究其原因，可能是MVC 三层架构的影响，太多人的代码里头只剩下了pojo这种贫血模型。封装，继承，多态，抽象是啥，早就忘干净了。
在软件设计方面，很多人习惯了一开始就设计数据库表结构，结果就是代码逻辑跟数据库构成了强耦合，数据库一改，代码基本上会被改个彻底。在这种情况下，我们用的java面向对象的语言，结果却写的是面向过程的代码，这种代码基本没有可维护，可扩展，更没有可测试性一说。所以，面向对象的这个词语，被太多的人只是挂在嘴边上了，落实到代码里边，就成了面向过程。
在意识到这个问题后，我花了一段时间重新回顾了一遍面向对象的知识，并试图用来改进代码质量，这个过程是充满坎坷的，我总结了一些自己的体会：
1： 要真正落地面向对象编程，面向对象设计是前提，没有面向对象的设计意识，写着写着就成了面条代码。
2：以前只知道封装、继承、多态，全然忽视了最重要的抽象，抽象是封装、继承、和多态的基础。合理的抽象源于对业务主体的合理分析和认识。合理的抽象，应该是自洽的，易于理解的。
3：关于组合和聚合的关系，最核心的区别就是生命周期的区别，组合关系中，整体和部分是一个整体，离开了整体，部分没有意义，同时产生，同时销毁，而聚合关系中，部分单独存在也可以是有意义的。
4：别滥用继承，继承的作用更多的时候使用多态的特性。
关于UML ：

我觉得今年对我来说，是重新认识“面向对象”的一年。
今年事我工作的第三年了（从八月份开始算第三年），年初的时候误打误撞的学了一段时间的DDD，让我瞬间感受到了什么才是面向对象编程，之前自己做的都是用面向对象的语言写面向过程的代码。究其原因，可能是MVC 三层架构的影响，太多人的代码里头只剩下了pojo这种贫血模型。封装，继承，多态，抽象是啥，早就忘干净了。
在软件设计方面，很多人习惯了一开始就设计数据库表结构，结果就是代码逻辑跟数据库构成了强耦合，数据库一改，代码基本上会被改个彻底。在这种情况下，我们用的java面向对象的语言，结果却写的是面向过程的代码，这种代码基本没有可维护，可扩展，更没有可测试性一说。所以，面向对象的这个词语，被太多的人只是挂在嘴边上了，落实到代码里边，就成了面向过程。
在意识到这个问题后，我花了一段时间重新回顾了一遍面向对象的知识，并试图用来改进代码质量，这个过程是充满坎坷的，我总结了一些自己的体会：
1： 要真正落地面向对象编程，面向对象设计是前提，没有面向对象的设计意识，写着写着就成了面条代码。
2：以前只知道封装、继承、多态，全然忽视了最重要的抽象，抽象是封装、继承、和多态的基础。合理的抽象源于对业务主体的合理分析和认识。合理的抽象，应该是自洽的，易于理解的。
3：关于组合和聚合的关系，最核心的区别就是生命周期的区别，组合关系中，整体和部分是一个整体，离开了整体，部分没有意义，同时产生，同时销毁，而聚合关系中，部分单独存在也可以是有意义的。
4：别滥用继承，继承的作用更多的时候使用多态的特性。
关于UML ：
在工作的过程中，试着画过UML图，UML图有着自己一条完整的语言和生态，学习成本还是相当高的，问题在于，即使用了标准的UML 图，如果沟通过程中，对方不懂，也依然效果不大，所以我对UML的感觉就是: 能看懂，会画基本的即可，没必要太追求标准化，虽然如此，但是UML 还是很重要的，它的意义是提供一种面向对象设计的表达方式，是学习面向对象设计中不可缺少的一部分（个人理解）。

2019-11-11







